<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>GIT_AND_GITHUB_COLT-STEELE</title>
</head>
<body>
    <header class="header"><u>COLT STEELE GIT-GITHUB NOTES</u></header>
    <div class="myIntro">
    <h1>I am going to be taking notes with this html page,
        this is colt_steele's intro to git/github,
        I have a little experience since I did THE ODIN PROJECT
        FOUNDATIONS, but I know I need to practice
        and retain more in regards to version control, so this is just going to
        be notes for myself.
    </h1>
    </div>
    <div>
        <h2>So git and github are the most widely used version
            control tool across programming, so for a new developer
            the best time to learn and become familiar with Git is 
            yesterday, it's that important. It's going to be very important
            to start using and living Git, it takes a lot of practice
            so we'll start using it for all our learning projects going forward.
            I'll need to incorporate it in my next and current colt steele course
            which is the web develormper bootcamp/ react bootcamp, I'm already halfway 
            through colt's complete javascript bootcamp so i'll utilize git from now 
            until the end of that.
        </h2>
    </div>
    <div>
        <h1>THE COURSE GAMEPLAN:</h1>
        <h2>
        <ul>
            <li>Educational (Hopefully)</li>
            <li>Entertaining (When possible)</li>
            <li>Interactive (Lot's of exercises!)</li>
            <li>Visually interesting (Tons of diagrams)</li>
        </ul>
        </h2>
    </div>
    <div>
        <h1>
The course cirriculum:
    </h1>
    </div>
    <div>
        <h2>
<ol>
<li><h2>Intro to git</h2></li>
<li><h2>Installation</h2></li>
<li><h2>Git Basics</h2></li>
<li><h2>Committing in detail</h2></li>
<li><h2>Branching</h2></li>
<li><h2>Merging</h2></li>
<li><h2>Diffing</h2></li>
<li><h2>Stashing</h2></li>
<li><h2>Undoing changes</h2></li>
<li><h2>Github intro</h2></li>
<li><h2>Fetching and pulling</h2></li>
<li><h2>Github odds and ends</h2></li>
<li><h2>Collaborative workflows</h2></li>
<li><h2>Rebasing</h2></li>
<li><h2>Interactive rebasing</h2></li>
<li><h2>Git tags</h2></li>
<li><h2>Git behind the scenes</h2></li>
<li><h2>Reflogs</h2></li>
<li><h2>Custom aliases</h2></li>
<li><h2>???</h2></li>
</ol>
        </h2>
    </div>
    <div>
       <h1>So not all of the above are part of the git core,
        the git core of this bootcamp are the first six of the above
        ordered list:
</h1>
<div>
    <ul>
       <li><h2>Intro to git</h2></li>
        <li><h2>Installation</h2></li>
        <li><h2>Git Basics</h2></li>
        <li><h2>Committing in detail</h2></li>
        <li><h2>Branching</h2></li>
        <li><h2>Merging</h2></li>
</ul>
</div>
    </div>
    <div>
        <h1>
            Then after we go over the core of git we'll look at
            what colt calls "next level git":
        </h1>
        <ul>
            <li><h2>Diffing</h2></li>
            <li><h2>Stashing</h2></li>
            <li><h2>Undoing changes</h2></li>
        </ul>
    </div>
    <div>
        <h2>The above don't come up nearly as often as the git core</h2>
    </div>
    <div>
        <h1>
      Now we move onto the next 4 which is Github and collaboration:
    </h1>
    <div>
        <ul>
            <li><h2>Github intro</h2></li>
            <li><h2>Fetching and pulling</h2></li>
            <li><h2>Github odds and ends</h2></li>
            <li><h2>Collaborative workflows</h2></li>
        </ul>
    </div>
    </div>
    <div>
        <h1>
           So in the above section we go over github pages and github gists,
           and collaboration workflows, different structures and strategies
           some developer teams employ using github
        </h1>
    </div>
    <div>
<h2>So after the above we get to the final section which is just a mixture of
    other git stuff, some of it is more niche but still important, some of
    the stuff you may never use, but it's important to understand the use
    cases for what they can provide to a developer
</h2>
<div>
    <ul>
        <li><h2>Rebasing</h2></li>
        <li><h2>Interactive rebasing</h2></li>
        <li><h2>Git tags</h2></li>
        <li><h2>Git behind the scenes</h2></li>
        <li><h2>Reflogs</h2></li>
        <li><h2>Custom aliases</h2></li>
    </ul>
</div>
<div>
    <h1>Next up let's go over how the exercises of the course work,
       these are important to fully immerse yourself with git, so doing
       them is a requirement, it's about the workflows. Practice is a must,
       it's not optional.
    </h1>
</div>

<div><h1><u>INTRODUCING..... GIT!</u></h1></div>
<h1>So the main takeways in this section are:
    <ul><li>What is git?</li></ul>
    <ul><li>Difference between git and github</li></ul>
    <ul><li>What does git do for us</li></ul>
</h1>

</div>

<div>
    <h1>What is git?</h1>
    <div>
    <h2>Git is the worlds most popular version control system (VCS)</h2>
    <h2>Version control is software that tracks and makes changes to files
        over time, extremely important, most VCS allow users to revisit earlier 
        versions of files, compare changes between versions, undo changes
        and much more
    </div>

    <div>
<h2>
Git is just one VCS, there are many others like Subversion, CVS, and Mercurial,
they all have similar goals but we mainly use git because git is the clear
winner, in a survey 88.4% of developers use git day to day
</h2>
    </div>
   
    </div>
    <div>
        <h1>Now let's discuss what exactly git does for us</h1>
        <h2>Git helps us:
            <ul><li>Track file changes</li></ul>
            <ul><li>Compare versions of a project</li></ul>
            <ul><li>"Time travel" back to earlier versions</li></ul>
            <ul><li>Revert to a previous version</li></ul>
            <ul><li>Collaborate and make changes</li></ul>
            <ul><li>Combine changes</li></ul>
            Git facilitates collaboration
        </h2>
        <h2>Think of it like separate save files in the Witcher 3
            or any game with separate save states, you can travel back
            to when you first started the game if you made these "checkpoints"
            or saves, and we can even merge our save states depending
            on our goals.
        </h2>
        <div>
            <h1>Linus Torvalds is the creator of Git, he created it himself, 
            he wanted Git to be free, not a paid DVCS
        </h1>
        </div>
    </div>
    <div>
       <h1>Huge companies use Git, companies like Google, Netflix,
         Microsoft, Twitter, and even governments make use of git,
         Washington DC city council utilize git.
         </h1>
    
    </div>
<div>
    <h1><u>Git Vs. Github</u></h1>
    <div>
        <h1><u>Git</u></h1>
        <h2>Git is the VCS that runs locally on your machine,
            you don't need to register an account. You don't need
            internet to use Git, you can utilize git without
            ever even touching Github
        </h2>
        <div>
            <h1><u>Github</u></h1>
            <h2>Github is a service that hosts git repositories (repos)
                in the cloud and makes it much easier to collaborate 
                with others. You do need a Github account to use Github,
                It's a place to share work done using Git on your local
                machine
            </h2>
        </div>
        <h1>We're going to start with Git in this course then 
          move to Github
        </h1>
    </div>
</div>
<div>
    <h1>The next section we go over installing and setting up Git</h1>
</div>

<div>
    <h1><u>Installing Git, terminals vs GUI's </u></h1>
<h2> We're going to start with the command line first then
    we'll use a GUI to see what that's like, the GUI we're 
    going to utilize later is: GitKraken
</h2>
<h2>GitKraken is free and it's the GUI that colt recommends</h2>
</div>
<div>
    <h1><u>TERMINAL CRASH COURSE</u></h1>
    <h2>In this section I'm going to run through some of the 
        essential terminal commands for navigation for
        moving around on your machine.
         We need this in order to work with Git.
         Commands like ls and pwd, and cd: 
    
    <ul>
        <li>"start ." command - this command will open the file explorer 
        of whatever directory you're inside of
    </li>
</ul>

<ul>
<li>
    "ls" the ls command will display all files currently inside of the PWD or
    present working directory, we can also use ls with a folder name to display
    whats inside of a selected folder like "ls 'Pictures'" or "ls 'Desktop'"
</li>
</ul>

<ul>
<li>
    Anyway, the next command I'll show you is pretty simple.
It's called 'pwd' for print working directory.
And what this will do, it's very simple.
It just prints out your current location.
It prints out the path to where you currently are.
</li>
    </ul>

    <ul>
        <li>So to our next command which is 'cd' (change directory) it's the 
        equivalent of changing folders in file explorer. So to change directories
        we can go from something like /Desktop to /Desktop/GIT_AND_GITHUB_COLT-STEELE
        by using the cd command followed by the directory name so the above would be:
        cd /GIT_AND_GITHUB_COLT-STEELE
    </li>
</ul>
<ul>
    <li>
        Now let's look at how to move 1 directory backwards. So if we're stll inside
        /Desktop/GIT_AND_GITHUB_COLT-STEELE, we would do 'cd ..' cd followed
        by two dots .., now we're back into just /Desktop
    </li>
</ul>
<h1><u>Terminal Crash Course: Creating Files & Folders</u></h1>
<h2>To create a new file we use the 'touch' command followed
    by the name we want to assign to the file so for ex:
 ////   touch index.html style.css script.js ////
 so after we run that command three files will be created inside
 of whichever directory we are in, an html, css, and javascript file
</h2>
<h2>
    Now lets look at how to create folders or directories, the 
    command is: mkdir myDirectory // so we now created a directory called
    myDirectory and if we cd into it we can create more directories inside 
    of it, or just create files, or both. mkdir is just a way to organize
    files. You can have directories inside of directories and even more directories
    inside those with files inside all of them. It's a good way to organize
    your files.
</h2>
  </h2>
  
 <h1><u>Terminal Crash Course: Deleting Files and Folders</u></h1>
 <h2>To delete a file we use the command 'rm' followed ny the name
    of the file. Remember this fully deletes the file it doesn't just
    send it to the recycling bin like using delete on the Desktop
    would, after using 'rm' the file is fully gone, so be careful with this
    command.
 </h2>
 <h2>
    Now keep in mind we can't use the 'rm' command to delete directories,
    instead to delete full directories we must use 'rm -rf' command,
    so it's just rm with the -rf flag after followed by the directory name
     (rm -rf testDirectory), this would delete the testDirectory 
 </h2>
 <h2>
    We can add flags to a lot of commands, one is ls -a, that command
    will display all files including hidden files, so -a modifies the 
    behavior of ls
 </h2>
 <h1><u>Git Repos</u></h1>
 <h1>What really matters in this next section</h1>
 <h2>We're going to go over what git repos are, and we'll learn 'git init',
    'git status' commands, we'll also go over the git folder and what's 
    inside of it, the Committing workflow, an important concept to 
    incorporate into your daily coding routine, we'll also discuss three 
    more commands 'git add', 'git commit', 'git log', these are very important
    commands, so practicing them is crucial
 </h2>
 <h2><u>Repository</u></h2>
 <h2>A git 'repo' is a workspace which tracks and manages files
    within a folder, anytime we use Git with a project, app, etc we need to
    create a new git repo or Repository, we can have as many repos as 
    we need, all with separate histories and contents
 </h2>
 <h2>So just because we have git installed doesn't mean we're
    automatically using it, we have to tell git we're creating a new
    Repository, it's a unique workplace with it's own history, each
    repo is like encapsulated bubbles. 
 </h2>
 <h2>For example if we want a repo inside a specific folder 
    or directory we must tell Git: Ok I want a repo inside this directory.
    And whatever commands I run are specific to that repo.

 </h2>
 <h2>Now that we know what repos are in general, let's
    go over how to intialize a new repo using git, but first let's go over
    the 'git status' command, and the 'git init' command 
 </h2>
 <h2>
    <ul>
<li><h2>'Git Status' Command</h2></li>
<h3>The 'Git status' command will give us info about the current repo,
    if there's a repo the command will return something like: "On branch 
    gitdemo nothing to commit, working tree clean"
    if there isn't a repo in the specified location 'git status' will
    return an error
</h3>
<li>
   <h2>'Git init' Command</h2>
</li>
<h3>
    So when we use 'Git init' whatever folder or directory we are inside
    will become the location of a new git Repository, keep in mind
    we only ever run 'git init' once per project, so if we had a 
    project myWebsite, we use 'git init' at the beginning, and we 
    could work on myWebsite project for years and years, we only
    use 'git init' once at the start of a git repo, we want that continued
    history.
</h3>
 </ul>
</h2>
Now there is a hidden file/folder that is created when we use git init,
for example if we type 'ls -a' inside our current directory it shows 
the following: ./ , ../ , .git/ , index.html , style.css, script.js
<h2> We can even cd into the .git folder and it will
   show things like: 'HEAD', 'config', 'description', 'hooks', 'refs',
   'info', 'objects', we can also delete the .git folder but beware, this
   deletes the repo entirely, rm -rf .git, the .git folder is where
   everything is stored, that's why it's a hidden folder, so you don't
   accidentally delete or mess with it.
</h2>
<h1><u>Common early git mistakes</u></h1>
<h2>
   So it's important to understand when we initialize a git 
   repo, anything nested inside the directory that we intialize with
   'git init' is tracked, so you could have folders inside of directories,
   inside of directories inside of more directories, all that is tracked
   if we use 'git init' in the parent directory, it tracks every file change
   all the way down.
</h2>
<h1><em><u>WARNING! DO NOT INIT A REPO INSIDE OF A REPO,
   BEFORE RUNNING GIT INIT, USE GIT STATUS TO VERIFY
   THAT YOU'RE NOT CURRENTLY INSIDE A REPO
</u></em></h1>
<h2>We want to keep our repo's separate, because it can cause
   problems later on, avoid this. Just make sure to always use
'git status' to double check </h2>
<h1><u>The committing workflow overview</u></h1>
<h2>
   What is committing? Committing is using checkpoints or  like saves
   in a video game, you add a nav bar then commit, then change something,
   else and commit that change, on and on. Like in a game you can make 
   a save early on, then revisit that early save after some time so see
   a previous version of your character. We can undo commits, revisit early
   commits, merge commits.
</h2>
<h1><u>Git add/commit command</u></h1>
<h2>
   This is the first command we use when we want to make a commit,
   the workflow is usually like:
   <ol>
       <li>Work on stuff, make new files, edit or delete files</li>
       <li>Add the changes with 'git add', where we group
           specific changes together in preparation of committing,
           now the files we specify to add are now in the staging area
       </li>
       <li>Commit the changes with 'git commmit', Commit
           everything that we just added with 'git add', now the files
           that are in the staging area are commited, usually followed by 
           a commmit message 'git commit -m  "message here"', the message should
           summarize the changes made concisely

       </li>
   </ol>
</h2>
<h2>To reiterate when we commit we always include: git commit -m "message here"
   with a massage as descriptive and concise as possible
</h2>
<h2>
    Also to add multiple files to the staging area, you would
    use the command: git add . 
</h2>
<h2>
    So (git add .) git add plus a dot at the end will stage all
    modified files, so if we changed index.html and style.css in
    in this repo then did git add . both files would be staged, but
    you could technically stage 10 modified files or 50 or 100 using
    git add .
</h2>

<h1>Git committing exercise</h1>
<h2>Okay so I just finished the git commit exercise
    and ran into a problem, there was an error being thrown 
    when I was trying to use (git add groceries.txt and yard.txt)
    after googling the error I found the fix to the problem 
    on stack overflow, to fix the error message: 
</h2>
<h2>
    Another git process seems to be running in this repository, e.g.
    an editor opened by 'git commit'. Please make sure all processes
    are terminated then try again. If it still fails, a git process
    may have crashed in this repository earlier:
    remove the file manually to continue.
</h2>

<h2>We need to cd into our .git directory then use the 
    command: (rm -f .git/index.lock) and this fixes the 
    error message, hopefully this didn't do anything 
    bad inside our .git directory but I suppose we'll
    find out later? The error did not occur in colt's 
    demonstration so I'm not sure what I did specifically
    but after deletion it worked.  
</h2>
<h1>Commits in more detail</h1>
<h2>In the next section we're going to go over the following:</h2>
<h2>
<ul>
    <li>Atomic commits (important)</li>
    <li>Configuring default editor (important)</li>
    <li>Working with a GUI (Nice to have)</li>
    <li>Amending commits (Nice to have)</li>
    <li>Git ignore (Critically important)</li>
    <li>Navigating git documentation (important)</li>
</ul>
</h2>

<h1>ATOMIC COMMITS</h1>
<h2>It's common advice to keep your commits atomic, what does 
    atomic mean? It means keeping each commit focused on a single
    change. Commit after each individual change to 
    keep things tidy and easier to problem solve. So make a 
    commit after editing text, or after implementing a css change,
    or after doing something in your JS file etc.. This practice 
    ensures an easier time identifying bugs in order to 
    preserve the work you've done that isn't problematic. Atomic
    commits make your code easier to review.
</h2>
<h2>When writing commit messages you should use present tense
    commit messages, so for ex: Writing "Make website color chnage",
    instead of "Made website color change", but I don't know, it 
    seems a little pedantic but I suppose if an employer prefers
    one or the other go with that.
</h2>
<h1>A closer look at Git Log command</h1>
<h2>We can use the "git log --oneline" to show a concise
    version of our log. This is useful and we'll go over shortly
    why it's so important. In essence it makes it easier to see
    when we need to time travel back to, which commit needs to 
    be gone back to.
</h2>
<h1>Commiting with a GUI like GitKraken</h1>
<h2>Even if you're not interested in using a GUI, learning
    about commits in GUI's are important, worth checking out. They
    help with visualizing commits.
</h2>
<h2>So using the GUI you press stage changes on the right 
    side of the GUI, then it asks for a commit message, then
press commit changes to file. This accompishes the same
exact thing as in GitBash git add, git status, git commit -m etc.. </h2>
<h2>GitKraken seems really nice, I may start using it often, I guess
    once we go over branching and merging the visualiztion of a 
    GUI can be very useful
</h2>
<h1>==============</h1>
<h1>Amending Commits</h1>
<h1>==============</h1>
<h2>Sometimes mistakes when commiting happen, so instead
    of doing a new commit we can amend previous commits using
    the --amend flag
</h2>
<h2>Keep in mind this ONLY works on the very last commit made
    you may not go back more than one commit using amend flag, 
    --amend only works on the last commit
</h2>
<h2>Okay so this --amend isn't working for me, I'm getting an 
    error message saying:
    <h2>unknown option: --amend
    usage: git [--version] [--help] [-C <path>] [-c <name>=<value>]
               [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
               [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]
               [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
               [--super-prefix=<path>] [--config-env=<name>=<envvar>]
               <command> [<args>]
               </h2>
               <h2>
               Will come back to this later to see what I'm doing wrong
               
            </h2>
<h1>=======================</h1>
            <h1>Ignoring files with /.gitignore </h1>
 <h1>=======================</h1>    
            <h2>We can tell git which directories and files
                to ignore in a given repository, we use .gitignore
                This is useful for things you know you never want to Commit
                like:
                <ul>
                    <li>Secrets, API keys, credentials etc..</li>
                    <li>Operating system files</li>
                    <li>Log files</li>
                    <li>Dependencies & packages</li>
                </ul>
            </h2>
            <h2>Typically we put .gitignore in the root of a repository
                We tell git which files to ignore, let's practice This
                by making a new directory called gitIgnoreDemo 
            </h2>
            <h2>So colt just used git ignore to ignore some json files, 
                as well as a secrets.txt file that contains a fake API key,
                and using git ignore he made it so those files did not 
                show up in gitBash so they would never be accidentally 
                added
            </h2>
            <h1>================================</h1>
         <h1><u>Working with branches in git</u></h1>
            <h1>================================</h1>
            <h1>Critical importance:</h1>
            <h2><ul>
                <li>Branching... what is it and why use it?</li>
                <h4>This is a part of git that must be mastered 
                    in order to use git day to day, learning branching
                    is vital to git workflow, branching along with 
                    commits happen daily in the life of a developer
                 </h4>
                <li>Understanding git HEAD</li>
                <h4>Also critical is understanding git HEAD, what HEAD is
                    and the fact that it points to a branch reference and that
                    reference points to a commit
                 </h4>
                <li>Git branch</li>
                <li>Git switch</l1>
                <li>Git checkout</li>
                <h4>Also crucial is understanding the branch command, the git 
                    switch command, the git checkout command
                 </h4>
            </ul></h2>
      
        
       
         <h2>Important but not crucial in this section is:
            deleting and renaming branches, and Master vs Main branch
         </h2>
         <h2>Nice to have but not super important is HEAD and ref 
            behind the scenes
         </h2>
    <h1>==========================</h1>
         <h1><u>INTRODUCING BRANCHES</u></h1>
         <h1>==========================</h1>
         <h2>Every commit has a unique hash, and each commit references 
            the commit that came before it. There is a linear history, but 
            in the real world we need to work in multiple contexts simultaneously 
            
         </h2>
         <h2>So imagine I'm working, I don't know, I work at some company, I'm working on a web application and
            I'm trying out two different color scheme variations for a website.
             And I want to try them both out and figure out which one I like best.
             And at the same time, I also have been tasked with trying to fix a really horrible bug.
             <h2>
               But this bug is proving very difficult to solve 
            I'm actually needing to delete some code and comment stuff out, move stuff around to try and hunt down
            the bug.
            So it's not as simple as just fixing a typo.
            I have to like totally destroy part of the code base to find this bug.
            </h2>
            <h2>
             And at the same time, one of my teammates is working on adding a new feature, a little chat bot and
             the bottom corner.
             You know, those things that pop up and you can chat with customer service or something.
             It's not clear at the moment if our company wants to use that, but he's going ahead and trying it as
             a bit of an experiment.
             </h2>
             <h2>
             And then another coworker is adding some new functionality to the search bar autocomplete, and yet
             another developer is doing something very different.
             She is doing a very experimental radical design overhaul of our entire application layout, but it won't
              be presented until next month and we don't even know if any of it will be used after next month.
              So lots of different contexts.
              </h2>
              <h2>
             If we all worked in a linear fashion, one commit after the next, this would be practically impossible.
             How could we be working on separate things, some of which break other people's code?
            Right.
            If I'm trying to fix a horrible bug and deleting a bunch of code, removing files, I'm just making
            a mess.
            </h2>
            <h2>
            That's going to be a big problem if somebody else is trying to add a new feature.
            Likewise, if someone is doing a radical experimental design change on every single view of our application,
            everything changes.
            </h2>
            <h2>
            But I'm trying to work on some minor color scheme variations, or if someone's working on adding a chat
            widget to the bottom right of our screen.
            Those things need to happen in separate contexts because they have implications on one another and they
            really need to happen in isolation until maybe at some point we decide to incorporate changes into each
            other's contexts.
            </h2>
            <h2>
            So that is where branching comes in.
             That's exactly what git branches allow us to do.
             Branches are a signature feature of Git and you can kind of think of them as alternative timelines for
             a project.
             </h2>
             <h2>
            They allow us to create separate contexts whenever we want.
            We can try new things.
            We can work on multiple ideas in parallel.
            We can experiment, we can break stuff, and whatever we do on one branch will not impact what happens
            on other branches, although we can decide to then combine branches, we call that merging and we'll
            learn how to do that.
            </h2>
            <h2>
            But that's something we have to decide to do.
            Otherwise, if we make a change in one branch, the other branches do not know about it.
            They exist in isolation.
            So this allows me to make a commit and maybe make another commit on one branch and then at any point
            splinter off and try something on this pink branch up top.
            </h2>
            <h2>
            I'm calling New Color Scheme.
            I could try a new color scheme out, but over here, if I switch back to this branch, none of that
            code comes with me.
            None of those new commits.
            So I could branch off again and work on a bug fix.
            </h2>
            <h2>
            But again, totally separate context.
            And then I could branch off even further from this bug fix branch and branch further to do an experimental
            redesign.
            So now I have at least four different contexts one, two, three and four.
            </h2>
            <h2>
            And this means that I could be working on this and maybe somebody else is working on this branch and
            somebody else is working here or.
            Maybe someone else is working on this purply bluish branch in the middle and working on things plotting
            ahead.
            </h2>
            <h2>
        Well, I'm still stuck here.
             We're all working in separate contexts, but then a very important part is being able to then combine
            and merge branches together when appropriate.
            </h2>
            <h2>
            If you work on a bug fix and you actually solve it, then you want to merge that bug fix into the main
            code base or into another branch.
            So we'll learn how to do all of this in time.
            </h2>
            <h2>
            But I'm going to stop talking for now.
            In this video, I just wanted to introduce this idea of branching, of having separate contexts.</h2>
























</body>
<script src="script.js"></script>
</html>