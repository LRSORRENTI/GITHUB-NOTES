<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>GIT_AND_GitHub_COLT-STEELE</title>
</head>
<body>
    <header class="header"><h1><u>COLT STEELE GIT-GitHub NOTES</u></h1></header>
    <div class="myIntro">
    <h2>I am going to be taking notes with this html page,
        this is colt_steele's intro to git/GitHub,
        I have a little experience since I did THE ODIN PROJECT
        FOUNDATIONS, but I know I need to practice
        and retain more in regards to version control, so this is just going to
        be notes for myself.
    </h2>
    <h2>Note I plan on adding multiple html pages, with links to each section/page instead of this gigantic html 
        page, I want to make these notes looks nice!
    </h2>
    <h2>
        Here's a list of tags that will take you to specified 
        points in the html page
    </h2>
    <ul>
        <li><a href="course_gameplan">Course gameplan</a></li>
    </ul>
    </div>
    <div>
        <h3>So git and GitHub are the most widely used version
            control tool across programming, so for a new developer
            the best time to learn and become familiar with Git is 
            yesterday, it's that important. It's going to be very important
            to start using and living Git, it takes a lot of practice
            so we'll start using it for all our learning projects going forward.
            I'll need to incorporate it in my next and current colt steele course
            which is the web develormper bootcamp/ react bootcamp, I'm already halfway 
            through colt's complete javascript bootcamp so i'll utilize git from now 
            until the end of that.
        </h3>
    </div>
    <div>
        <h2>THE COURSE GAMEPLAN:</h2>
        <h3>
            <a id="course_gameplan"></a>
        <ul>
            <li>Educational (Hopefully)</li>
            <li>Entertaining (When possible)</li>
            <li>Interactive (Lot's of exercises!)</li>
            <li>Visually interesting (Tons of diagrams)</li>
        </ul>
        </h3>
    </div>
    <div>
        <h2>
The course cirriculum:
    </h2>
    </div>
    <div>
        <h3>
<ol>
<li><h3>Intro to git</h3></li>
<li><h3>Installation</h3></li>
<li><h3>Git Basics</h3></li>
<li><h3>Committing in detail</h3></li>
<li><h3>Branching</h3></li>
<li><h3>Merging</h3></li>
<li><h3>Diffing</h3></li>
<li><h3>Stashing</h3></li>
<li><h3>Undoing changes</h3></li>
<li><h3>GitHub intro</h3></li>
<li><h3>Fetching and pulling</h3></li>
<li><h3>GitHub odds and ends</h3></li>
<li><h3>Collaborative workflows</h3></li>
<li><h3>Rebasing</h3></li>
<li><h3>Interactive rebasing</h3></li>
<li><h3>Git tags</h3></li>
<li><h3>Git behind the scenes</h3></li>
<li><h3>Reflogs</h3></li>
<li><h3>Custom aliases</h3></li>
<li><h3>???</h3></li>
</ol>
        </h3>
    </div>
    <div>
       <h2>So not all of the above are part of the git core,
        the git core of this bootcamp are the first six of the above
        ordered list:
</h2>
<div>
    <ul>
       <li><h3>Intro to git</h3></li>
        <li><h3>Installation</h3></li>
        <li><h3>Git Basics</h3></li>
        <li><h3>Committing in detail</h3></li>
        <li><h3>Branching</h3></li>
        <li><h3>Merging</h3></li>
</ul>
</div>
    </div>
    <div>
        <h2>
            Then after we go over the core of git we'll look at
            what colt calls "next level git":
        </h2>
        <ul>
            <li><h3>Diffing</h3></li>
            <li><h3>Stashing</h3></li>
            <li><h3>Undoing changes</h3></li>
        </ul>
    </div>
    <div>
        <h3>The above don't come up nearly as often as the git core</h3>
    </div>
    <div>
        <h2>
      Now we move onto the next 4 which is GitHub and collaboration:
    </h2>
    <div>
        <ul>
            <li><h3>GitHub intro</h3></li>
            <li><h3>Fetching and pulling</h3></li>
            <li><h3>GitHub odds and ends</h3></li>
            <li><h3>Collaborative workflows</h3></li>
        </ul>
    </div>
    </div>
    <div>
        <h2>
           So in the above section we go over GitHub pages and GitHub gists,
           and collaboration workflows, different structures and strategies
           some developer teams employ using GitHub
        </h2>
    </div>
    <div>
<h3>So after the above we get to the final section which is just a mixture of
    other git stuff, some of it is more niche but still important, some of
    the stuff you may never use, but it's important to understand the use
    cases for what they can provide to a developer
</h3>
<div>
    <ul>
        <li><h3>Rebasing</h3></li>
        <li><h3>Interactive rebasing</h3></li>
        <li><h3>Git tags</h3></li>
        <li><h3>Git behind the scenes</h3></li>
        <li><h3>Reflogs</h3></li>
        <li><h3>Custom aliases</h3></li>
    </ul>
</div>
<div>
    <h2>Next up let's go over how the exercises of the course work,
       these are important to fully immerse yourself with git, so doing
       them is a requirement, it's about the workflows. Practice is a must,
       it's not optional.
    </h2>
</div>

<div><h2><u>INTRODUCING..... GIT!</u></h2></div>
<h2>So the main takeways in this section are:
    <ul><li>What is git?</li></ul>
    <ul><li>Difference between git and GitHub</li></ul>
    <ul><li>What does git do for us</li></ul>
</h2>

</div>

<div>
    <h2>What is git?</h2>
    <div>
    <h3>Git is the worlds most popular version control system (VCS)</h3>
    <h3>Version control is software that tracks and makes changes to files
        over time, extremely important, most VCS allow users to revisit earlier 
        versions of files, compare changes between versions, undo changes
        and much more
    </div>

    <div>
<h3>
Git is just one VCS, there are many others like Subversion, CVS, and Mercurial,
they all have similar goals but we mainly use git because git is the clear
winner, in a survey 88.4% of developers use git day to day
</h3>
    </div>
   
    </div>
    <div>
        <h2>Now let's discuss what exactly git does for us</h2>
        <h3>Git helps us:
            <ul><li>Track file changes</li></ul>
            <ul><li>Compare versions of a project</li></ul>
            <ul><li>"Time travel" back to earlier versions</li></ul>
            <ul><li>Revert to a previous version</li></ul>
            <ul><li>Collaborate and make changes</li></ul>
            <ul><li>Combine changes</li></ul>
            Git facilitates collaboration
        </h3>
        <h3>Think of it like separate save files in the Witcher 3
            or any game with separate save states, you can travel back
            to when you first started the game if you made these "checkpoints"
            or saves, and we can even merge our save states depending
            on our goals.
        </h3>
        <div>
            <h2>Linus Torvalds is the creator of Git, he created it himself, 
            he wanted Git to be free, not a paid DVCS
        </h2>
        </div>
    </div>
    <div>
       <h2>Huge companies use Git, companies like Google, Netflix,
         Microsoft, Twitter, and even governments make use of git,
         Washington DC city council utilize git.
         </h2>
    
    </div>
<div>
    <h2><u>Git Vs. GitHub</u></h2>
    <div>
        <h2><u>Git</u></h2>
        <h3>Git is the VCS that runs locally on your machine,
            you don't need to register an account. You don't need
            internet to use Git, you can utilize git without
            ever even touching GitHub
        </h3>
        <div>
            <h2><u>GitHub</u></h2>
            <h3>GitHub is a service that hosts git repositories (repos)
                in the cloud and makes it much easier to collaborate 
                with others. You do need a GitHub account to use GitHub,
                It's a place to share work done using Git on your local
                machine
            </h3>
        </div>
        <h2>We're going to start with Git in this course then 
          move to GitHub
        </h2>
    </div>
</div>
<div>
    <h2>The next section we go over installing and setting up Git</h2>
</div>

<div>
    <h2><u>Installing Git, terminals vs GUI's </u></h2>
<h3> We're going to start with the command line first then
    we'll use a GUI to see what that's like, the GUI we're 
    going to utilize later is: GitKraken
</h3>
<h3>GitKraken is free and it's the GUI that colt recommends</h3>
</div>
<div>
    <h2><u>TERMINAL CRASH COURSE</u></h2>
    <h3>In this section I'm going to run through some of the 
        essential terminal commands for navigation for
        moving around on your machine.
         We need this in order to work with Git.
         Commands like ls and pwd, and cd: 
    
    <ul>
        <li>"start ." command - this command will open the file explorer 
        of whatever directory you're inside of
    </li>
</ul>

<ul>
<li>
    "ls" the ls command will display all files currently inside of the PWD or
    present working directory, we can also use ls with a folder name to display
    whats inside of a selected folder like "ls 'Pictures'" or "ls 'Desktop'"
</li>
</ul>

<ul>
<li>
    Anyway, the next command I'll show you is pretty simple.
It's called 'pwd' for print working directory.
And what this will do, it's very simple.
It just prints out your current location.
It prints out the path to where you currently are.
</li>
    </ul>

    <ul>
        <li>So to our next command which is 'cd' (change directory) it's the 
        equivalent of changing folders in file explorer. So to change directories
        we can go from something like /Desktop to /Desktop/GIT_AND_GitHub_COLT-STEELE
        by using the cd command followed by the directory name so the above would be:
        cd /GIT_AND_GitHub_COLT-STEELE
    </li>
</ul>
<ul>
    <li>
        Now let's look at how to move 1 directory backwards. So if we're stll inside
        /Desktop/GIT_AND_GitHub_COLT-STEELE, we would do 'cd ..' cd followed
        by two dots .., now we're back into just /Desktop
    </li>
</ul>
<h2><u>Terminal Crash Course: Creating Files & Folders</u></h2>
<h3>To create a new file we use the 'touch' command followed
    by the name we want to assign to the file so for ex:
 ////   touch index.html style.css script.js ////
 so after we run that command three files will be created inside
 of whichever directory we are in, an html, css, and javascript file
</h3>
<h3>
    Now lets look at how to create folders or directories, the 
    command is: mkdir myDirectory // so we now created a directory called
    myDirectory and if we cd into it we can create more directories inside 
    of it, or just create files, or both. mkdir is just a way to organize
    files. You can have directories inside of directories and even more directories
    inside those with files inside all of them. It's a good way to organize
    your files.
</h3>
  </h3>
  
 <h2><u>Terminal Crash Course: Deleting Files and Folders</u></h2>
 <h3>To delete a file we use the command 'rm' followed ny the name
    of the file. Remember this fully deletes the file it doesn't just
    send it to the recycling bin like using delete on the Desktop
    would, after using 'rm' the file is fully gone, so be careful with this
    command.
 </h3>
 <h3>
    Now keep in mind we can't use the 'rm' command to delete directories,
    instead to delete full directories we must use 'rm -rf' command,
    so it's just rm with the -rf flag after followed by the directory name
     (rm -rf testDirectory), this would delete the testDirectory 
 </h3>
 <h3>
    We can add flags to a lot of commands, one is ls -a, that command
    will display all files including hidden files, so -a modifies the 
    behavior of ls
 </h3>
 <h2><u>Git Repos</u></h2>
 <h2>What really matters in this next section</h2>
 <h3>We're going to go over what git repos are, and we'll learn 'git init',
    'git status' commands, we'll also go over the git folder and what's 
    inside of it, the Committing workflow, an important concept to 
    incorporate into your daily coding routine, we'll also discuss three 
    more commands 'git add', 'git commit', 'git log', these are very important
    commands, so practicing them is crucial
 </h3>
 <h3><u>Repository</u></h3>
 <h3>A git 'repo' is a workspace which tracks and manages files
    within a folder, anytime we use Git with a project, app, etc we need to
    create a new git repo or Repository, we can have as many repos as 
    we need, all with separate histories and contents
 </h3>
 <h3>So just because we have git installed doesn't mean we're
    automatically using it, we have to tell git we're creating a new
    Repository, it's a unique workplace with it's own history, each
    repo is like encapsulated bubbles. 
 </h3>
 <h3>For example if we want a repo inside a specific folder 
    or directory we must tell Git: Ok I want a repo inside this directory.
    And whatever commands I run are specific to that repo.

 </h3>
 <h3>Now that we know what repos are in general, let's
    go over how to intialize a new repo using git, but first let's go over
    the 'git status' command, and the 'git init' command 
 </h3>
 <h3>
    <ul>
<li><h3>'Git Status' Command</h3></li>
<h3>The 'Git status' command will give us info about the current repo,
    if there's a repo the command will return something like: "On branch 
    gitdemo nothing to commit, working tree clean"
    if there isn't a repo in the specified location 'git status' will
    return an error
</h3>
<li>
   <h3>'Git init' Command</h3>
</li>
<h3>
    So when we use 'Git init' whatever folder or directory we are inside
    will become the location of a new git Repository, keep in mind
    we only ever run 'git init' once per project, so if we had a 
    project myWebsite, we use 'git init' at the beginning, and we 
    could work on myWebsite project for years and years, we only
    use 'git init' once at the start of a git repo, we want that continued
    history.
</h3>
 </ul>
</h3>
Now there is a hidden file/folder that is created when we use git init,
for example if we type 'ls -a' inside our current directory it shows 
the following: ./ , ../ , .git/ , index.html , style.css, script.js
<h3> We can even cd into the .git folder and it will
   show things like: 'HEAD', 'config', 'description', 'hooks', 'refs',
   'info', 'objects', we can also delete the .git folder but beware, this
   deletes the repo entirely, rm -rf .git, the .git folder is where
   everything is stored, that's why it's a hidden folder, so you don't
   accidentally delete or mess with it.
</h3>
<h2><u>Common early git mistakes</u></h2>
<h3>
   So it's important to understand when we initialize a git 
   repo, anything nested inside the directory that we intialize with
   'git init' is tracked, so you could have folders inside of directories,
   inside of directories inside of more directories, all that is tracked
   if we use 'git init' in the parent directory, it tracks every file change
   all the way down.
</h3>
<h2><em><u>WARNING! DO NOT INIT A REPO INSIDE OF A REPO,
   BEFORE RUNNING GIT INIT, USE GIT STATUS TO VERIFY
   THAT YOU'RE NOT CURRENTLY INSIDE A REPO
</u></em></h2>
<h3>We want to keep our repo's separate, because it can cause
   problems later on, avoid this. Just make sure to always use
'git status' to double check </h3>
<h2><u>The committing workflow overview</u></h2>
<h3>
   What is committing? Committing is using checkpoints or  like saves
   in a video game, you add a nav bar then commit, then change something,
   else and commit that change, on and on. Like in a game you can make 
   a save early on, then revisit that early save after some time so see
   a previous version of your character. We can undo commits, revisit early
   commits, merge commits.
</h3>
<h2><u>Git add/commit command</u></h2>
<h3>
   This is the first command we use when we want to make a commit,
   the workflow is usually like:
   <ol>
       <li>Work on stuff, make new files, edit or delete files</li>
       <li>Add the changes with 'git add', where we group
           specific changes together in preparation of committing,
           now the files we specify to add are now in the staging area
       </li>
       <li>Commit the changes with 'git commmit', Commit
           everything that we just added with 'git add', now the files
           that are in the staging area are commited, usually followed by 
           a commmit message 'git commit -m  "message here"', the message should
           summarize the changes made concisely

       </li>
   </ol>
</h3>
<h3>To reiterate when we commit we always include: git commit -m "message here"
   with a massage as descriptive and concise as possible
</h3>
<h3>
    Also to add multiple files to the staging area, you would
    use the command: git add . 
</h3>
<h3>
    So (git add .) git add plus a dot at the end will stage all
    modified files, so if we changed index.html and style.css in
    in this repo then did git add . both files would be staged, but
    you could technically stage 10 modified files or 50 or 100 using
    git add .
</h3>

<h2>Git committing exercise</h2>
<h3>Okay so I just finished the git commit exercise
    and ran into a problem, there was an error being thrown 
    when I was trying to use (git add groceries.txt and yard.txt)
    after googling the error I found the fix to the problem 
    on stack overflow, to fix the error message: 
</h3>
<h3>
    Another git process seems to be running in this repository, e.g.
    an editor opened by 'git commit'. Please make sure all processes
    are terminated then try again. If it still fails, a git process
    may have crashed in this repository earlier:
    remove the file manually to continue.
</h3>

<h3>We need to cd into our .git directory then use the 
    command: (rm -f .git/index.lock) and this fixes the 
    error message, hopefully this didn't do anything 
    bad inside our .git directory but I suppose we'll
    find out later? The error did not occur in colt's 
    demonstration so I'm not sure what I did specifically
    but after deletion it worked.  
</h3>
<h2>Commits in more detail</h2>
<h3>In the next section we're going to go over the following:</h3>
<h3>
<ul>
    <li>Atomic commits (important)</li>
    <li>Configuring default editor (important)</li>
    <li>Working with a GUI (Nice to have)</li>
    <li>Amending commits (Nice to have)</li>
    <li>Git ignore (Critically important)</li>
    <li>Navigating git documentation (important)</li>
</ul>
</h3>

<h2>ATOMIC COMMITS</h2>
<h3>It's common advice to keep your commits atomic, what does 
    atomic mean? It means keeping each commit focused on a single
    change. Commit after each individual change to 
    keep things tidy and easier to problem solve. So make a 
    commit after editing text, or after implementing a css change,
    or after doing something in your JS file etc.. This practice 
    ensures an easier time identifying bugs in order to 
    preserve the work you've done that isn't problematic. Atomic
    commits make your code easier to review.
</h3>
<h3>When writing commit messages you should use present tense
    commit messages, so for ex: Writing "Make website color chnage",
    instead of "Made website color change", but I don't know, it 
    seems a little pedantic but I suppose if an employer prefers
    one or the other go with that.
</h3>
<h2>A closer look at Git Log command</h2>
<h3>We can use the "git log --oneline" to show a concise
    version of our log. This is useful and we'll go over shortly
    why it's so important. In essence it makes it easier to see
    when we need to time travel back to, which commit needs to 
    be gone back to.
</h3>
<h2>Commiting with a GUI like GitKraken</h2>
<h3>Even if you're not interested in using a GUI, learning
    about commits in GUI's are important, worth checking out. They
    help with visualizing commits.
</h3>
<h3>So using the GUI you press stage changes on the right 
    side of the GUI, then it asks for a commit message, then
press commit changes to file. This accompishes the same
exact thing as in GitBash git add, git status, git commit -m etc.. </h3>
<h3>GitKraken seems really nice, I may start using it often, I guess
    once we go over branching and merging the visualiztion of a 
    GUI can be very useful
</h3>
<h2>==============</h2>
<h2>Amending Commits</h2>
<h2>==============</h2>
<h3>Sometimes mistakes when commiting happen, so instead
    of doing a new commit we can amend previous commits using
    the --amend flag
</h3>
<h3>Keep in mind this ONLY works on the very last commit made
    you may not go back more than one commit using amend flag, 
    --amend only works on the last commit
</h3>
<h3>Okay so this --amend isn't working for me, I'm getting an 
    error message saying:
    <h3>unknown option: --amend
    usage: git [--version] [--help] [-C <path>] [-c <name>=<value>]
               [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
               [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]
               [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
               [--super-prefix=<path>] [--config-env=<name>=<envvar>]
               <command> [<args>]
               </h3>
               <h3>
               Will come back to this later to see what I'm doing wrong
               
            </h3>
<h2>=======================</h2>
            <h2>Ignoring files with /.gitignore </h2>
 <h2>=======================</h2>    
            <h3>We can tell git which directories and files
                to ignore in a given repository, we use .gitignore
                This is useful for things you know you never want to Commit
                like:
                <ul>
                    <li>Secrets, API keys, credentials etc..</li>
                    <li>Operating system files</li>
                    <li>Log files</li>
                    <li>Dependencies & packages</li>
                </ul>
            </h3>
            <h3>Typically we put .gitignore in the root of a repository
                We tell git which files to ignore, let's practice This
                by making a new directory called gitIgnoreDemo 
            </h3>
            <h3>So colt just used git ignore to ignore some json files, 
                as well as a secrets.txt file that contains a fake API key,
                and using git ignore he made it so those files did not 
                show up in gitBash so they would never be accidentally 
                added
            </h3>
            <h2>================================</h2>
         <h2><u>Working with branches in git</u></h2>
            <h2>================================</h2>
            <h2>Critical importance:</h2>
            <h3><ul>
                <li>Branching... what is it and why use it?</li>
                <h4>This is a part of git that must be mastered 
                    in order to use git day to day, learning branching
                    is vital to git workflow, branching along with 
                    commits happen daily in the life of a developer
                 </h4>
                <li>Understanding git HEAD</li>
                <h4>Also critical is understanding git HEAD, what HEAD is
                    and the fact that it points to a branch reference and that
                    reference points to a commit
                 </h4>
                <li>Git branch</li>
                <li>Git switch</l1>
                <li>Git checkout</li>
                <h4>Also crucial is understanding the branch command, the git 
                    switch command, the git checkout command
                 </h4>
            </ul></h3>
      
        
       
         <h3>Important but not crucial in this section is:
            deleting and renaming branches, and Master vs Main branch
         </h3>
         <h3>Nice to have but not super important is HEAD and ref 
            behind the scenes
         </h3>
    <h2>==========================</h2>
         <h2><u>INTRODUCING BRANCHES</u></h2>
         <h2>==========================</h2>
         <h3>Every commit has a unique hash, and each commit references 
            the commit that came before it. There is a linear history, but 
            in the real world we need to work in multiple contexts simultaneously 
            
         </h3>
         <h3>So imagine I'm working, I don't know, I work at some company, I'm working on a web application and
            I'm trying out two different color scheme variations for a website.
             And I want to try them both out and figure out which one I like best.
             And at the same time, I also have been tasked with trying to fix a really horrible bug.
             <h3>
               But this bug is proving very difficult to solve 
            I'm actually needing to delete some code and comment stuff out, move stuff around to try and hunt down
            the bug.
            So it's not as simple as just fixing a typo.
            I have to like totally destroy part of the code base to find this bug.
            </h3>
            <h3>
             And at the same time, one of my teammates is working on adding a new feature, a little chat bot and
             the bottom corner.
             You know, those things that pop up and you can chat with customer service or something.
             It's not clear at the moment if our company wants to use that, but he's going ahead and trying it as
             a bit of an experiment.
             </h3>
             <h3>
             And then another coworker is adding some new functionality to the search bar autocomplete, and yet
             another developer is doing something very different.
             She is doing a very experimental radical design overhaul of our entire application layout, but it won't
              be presented until next month and we don't even know if any of it will be used after next month.
              So lots of different contexts.
              </h3>
              <h3>
             If we all worked in a linear fashion, one commit after the next, this would be practically impossible.
             How could we be working on separate things, some of which break other people's code?
            Right.
            If I'm trying to fix a horrible bug and deleting a bunch of code, removing files, I'm just making
            a mess.
            </h3>
            <h3>
            That's going to be a big problem if somebody else is trying to add a new feature.
            Likewise, if someone is doing a radical experimental design change on every single view of our application,
            everything changes.
            </h3>
            <h3>
            But I'm trying to work on some minor color scheme variations, or if someone's working on adding a chat
            widget to the bottom right of our screen.
            Those things need to happen in separate contexts because they have implications on one another and they
            really need to happen in isolation until maybe at some point we decide to incorporate changes into each
            other's contexts.
            </h3>
            <h3>
            So that is where branching comes in.
             That's exactly what git branches allow us to do.
             Branches are a signature feature of Git and you can kind of think of them as alternative timelines for
             a project.
             </h3>
             <h3>
            They allow us to create separate contexts whenever we want.
            We can try new things.
            We can work on multiple ideas in parallel.
            We can experiment, we can break stuff, and whatever we do on one branch will not impact what happens
            on other branches, although we can decide to then combine branches, we call that merging and we'll
            learn how to do that.
            </h3>
            <h3>
            But that's something we have to decide to do.
            Otherwise, if we make a change in one branch, the other branches do not know about it.
            They exist in isolation.
            So this allows me to make a commit and maybe make another commit on one branch and then at any point
            splinter off and try something on this pink branch up top.
            </h3>
            <h3>
            I'm calling New Color Scheme.
            I could try a new color scheme out, but over here, if I switch back to this branch, none of that
            code comes with me.
            None of those new commits.
            So I could branch off again and work on a bug fix.
            </h3>
            <h3>
            But again, totally separate context.
            And then I could branch off even further from this bug fix branch and branch further to do an experimental
            redesign.
            So now I have at least four different contexts one, two, three and four.
            </h3>
            <h3>
            And this means that I could be working on this and maybe somebody else is working on this branch and
            somebody else is working here or.
            Maybe someone else is working on this purply bluish branch in the middle and working on things plotting
            ahead.
            </h3>
            <h3>
        Well, I'm still stuck here.
             We're all working in separate contexts, but then a very important part is being able to then combine
            and merge branches together when appropriate.
            </h3>
            <h3>
            If you work on a bug fix and you actually solve it, then you want to merge that bug fix into the main
            code base or into another branch.
            So we'll learn how to do all of this in time.
            </h3>
            <h3>
            But I'm going to stop talking for now.
            In this video, I just wanted to introduce this idea of branching, of having separate contexts.
        </h3>
        <h2>=================================</h2>
        <h2><u>THE MASTER BRANCH/MAIN BRANCH</u></h2>
        <h2>=================================</h2>

        <h3>
            So we're always by default on the master branch,
            we can change branches, but we'll always be 
            working on a branch, it's just the main/default 
            branch.
        </h3>
        <h3>When we first run git init on a new project/ 
            repo the default branch we always start with is 
            the master branch. Some developers treat the master/ 
            main branch as the true branch but it's really just 
            the default, you can make a different branch that's 
            not the master/main as your default that you want to work 
            with, but some devs will keep the master/main as their one 
            true branch. 
        </h3>
        <h2><i>One branch to rule them all, One branch to find them,
            One branch to bring them all, and in the darkness 
        bind them. </i></h2>

        <h3>So the master/main branch can be deleted or renamed
            or ignored entirely, it's up to the developer 
        on how they want their default or main branch to be set up </h3>

        <h3>Also keep in mind the default branch name is supposed 
            to be "Main", and not "Master", GitHub in 2020 renamed it 
            officially but you'll still see "master" since the change 
            was recent.
        </h3>

        <h3>It's a common workflow to set a new branch to mess 
            around and experiment with, and if it works, merge back to master 
            or keep it as a separate branch while maybe eventually merging back
        </h3>

         <h2>==========================</h2>
         <h2>What is HEAD?</h2>
         <h2>==========================</h2>
         <h3>Let's explore what (HEAD -> master) is</h3>
         <h3>HEAD is a pointer in Git, that refers to the current 
            location in your repository, it points to a specific, 
            branch reference, so far HEAD always points to the latest 
            commit you've made, but we'll see that we can move around 
            and the HEAD will change
         </h3>

  <h3> 
    Think of branches like bookmarks in a book, let's say you 
    and a few friends are reading/sharing the same book. Your 
    bookmark is blue, your friend John has a red bookmark, Jane 
    has a green one, and Mr.Smith has a teal one, at any given point 
    in time, each bookmark is unique to the person who's reading, 
    but we can view Johns branch or bookmark, or anyone who's reading 
    that same book, and the HEAD will change depending on who's branch 
    your currently viewing
  </h3>
  <h3> So to reiterate HEAD is a pointer/reference to a 
    branch pointer/reference, and a branch pointer is a 
    pointer/ reference to where the bookmark is in a book. We 
    can have many branches/bookmarks and each one has a branch 
    reference/pointer that shows where it is.
  </h3>
  <h3>So after every commit we make, we're on the same branch 
      but we can make new branches which we'll go over soon, 
      but when we switch to a new branch the HEAD follows us 
      there, Master/main branch still exists but HEAD is now 
      pointing to us, where we are with are new branch.
  </h3>
  <h3>But we can always go back to the main branch, then head will now 
    be pointing back at master/main , HEAD is just the current branch 
    we are working with.
  </h3>
<h2>==========================================================</h2>
<h2>Viewing all existing branches with "git branch" command</h2>
<h2>===========================================================</h2>

<h3>We can view all branches using the command "git branch", 
    the default branch in every repo is "Master/Main", though 
    we can change this.
</h3>
<h3>So we can type "git branch" and it shows the 
    result '* Master' since we are currently in the 
master branch  </h3>
<h3>But the * just indicates the branch we're inside of, 
    we could have four or five branches like: Master, John's bookmark, 
    Jane's bookmark, Mr.Smiths bookmark and if we're in Jane's bookmark 
    it would say * Jane's bookmark, because Jane's bookmark is 
    the branch we're currently inside, the branch w/ the asterisk 
    * next to it is our current branch.
</h3>
<h2>=================================</h2>
<h2>Creating Branches</h2>
<h2>=================================</h2>
<h3>To create a new branch we actually use the same command 
    'git branch' but we add a branch name after so it would be:
    'git branch "Johns_bookmark"
</h3>
<h3>Keep in mind we should use snake_case or camelCase 
    to name branches, avoid using spaces in branch names
</h3>
<h3>Also bear in mind when we create a branch we do not 
    automatically go inside it, we have to change branches with 
    the command git branch + branch name 
</h3>
<h3>So I just made a new branch called 'notes_branch' 
    using git branch 'notes_branch', then did git branch and 
    it was created, underneath master branch, there is my 
    newly created branch notes_branch, but keep in mind HEAD 
    is still pointing to "Master" because we have not switched 
    branches yet
</h3>
<h2>--------git switch--------</h2>
<h3>
We use the command (git switch + branch name) to switch 
to the specified branch, and voila, we're on a new branch, and HEAD is now pointing to 
the new branch
</h3>
<h3>Now when I type git status after using the command 
    git switch notes_branch it displays on branch notes_branch
</h3>
<h3>So i just did git commit -m"test new branch commit"
    this commit was made on our new notes_branch branch, 
</h3>

<h3>Now after we type git log, we see that we left the 
    master branch behind, our last commit is separate from our 
main/master branch, but like a bookmark, the master branch we left 
is still there, just as we left it, but we can switch back like we 
did before using git switch master
</h3>
<h3>And yes after switching back to master branch lines 821 to 
    839 disappeared from VsCode because this content I'm currently 
    typing is unique to this branch, the notes_branch of my 
    repo
</h3>
<h3>We're going to practice creating more branches, BUT KEEP IN MIND 
    WHERE YOU ARE/ WHERE THE HEAD IS POINTING TO WHEN 
YOU CREATE BRANCH MATTERS, if we use git branch notes_branch_two 
while head is pointing to notes_branch, notes_branch_two is a branch of notes_branch
not master, so where you use the branch command MATTERS </h3>
<h3>Okay so we just created a branch from a branch from a branch... 
    Remember notes_branch was a branch from master branch, now 
    we're inside notes_branch_two which is a branch off of notes_branch,
    which was a branch off of master. Branches from branches from 
    branches.
</h3>
<h2>============================================</h2>
<h2>git switch vs git checkout, the differences</h2>
<h2>============================================</h2>

<h2>Historically we used git checkout + branch name, and 
    it still works but git checkout does many extra things than 
    git switch, which is the reason git switch was created, 
    keep in mind you'll see git checkout used frequently 
    in older documentation/tutorials, some future co-workers 
    may use git checkout.
</h2>
<h3> So I just created a new branch then used git checkout to 
    change into it. And yes it works the asterisk is pointing to 
    my new_checkout_branch_test branch I just created
</h3>
<h3>
    So if you go to the official Git documentation there are many 
    more things git checkout does, we'll go over some of them later 
    but for now just know that git switch is how we usually 
    change branches
</h3>
<h2>==========================================</h2>
<h2>Creating and switching in one command</h2>
<h2>==========================================</h2>

<h3>We can create and switch to the newly created branch 
    with the '-c' flag right before our branch name, so it would look 
    like this: git switch -c switch_and_changed_branch
</h3>
<h3> To achieve the same using git checkout the command would 
    be: git checkout -b "branch-name-here", we use -b flag instead 
    of -c flag 
</h3>

<h3>Keep in mind if we're on a branch that's not 
    currently committed, and we try to switch, we'll get an error 
    that says "please commit or stash your changes", we'll learn 
    about stashes later but for now just know git will throw an 
    error if you try to switch without committing. 
</h3>
<h3>Also if you create a new file on your new branch, and forget 
    to commit, that file will follow you around, it won't throw 
    that error we got above, if you create a file in switch_and_changed_branch 
    then change to master branch, the file you created will follow 
    you there
</h3>
<h2>=================================</h2>
<h2>Deleting and renaming branches</h2>
<h2>=================================</h2>
<h3>We use the git branch command again but instead we 
    append the -d flag with the corresponding branch 
we want to delete </h3>
<h3> So I just switched to notes_branch_two and created 
    a new branch, then deleted it using the -d flag, I didn't 
    receive the same error colt did, Colt had an error pop up 
    that said: branch is not fully merged, run git branch -D 
    to delete, I guess uppercase -D is the force command to delete 
    branches if error messages pop up
</h3>
<h3>Let's go over how to rename branches</h3>
<h3> To rename it we use git branch + -m on the branch we 
    want to rename, yes it is the -m flag similar to 
    git commit -m for message but in this case -m refers to 
    'move/rename', Remember we have to be on the branch to rename it 
    I'm going to rename switch_and_changed_branch to switch_and_changed_branches 
    Okay it worked but we need to omit the "", using -m to 
    rename a branch, don't wrap the new name in ""
</h3>
<h2>=======================================</h2>
<h2>How git stores HEAD behind the scenes</h2>
<h2>=======================================</h2>
<h3>Okay so the below section is a direct transcript, colt goes over HEAD and how it stores hash references to commits made on 
certain branches.</h3>
<h3>
We're going to take a look at that dot git directory and I'll show you proof of head how it works.
The fact that it's just referencing a branch and that each branch reference is referencing a commit.
All right.
So let's go ahead and hop over here to our road trip playlist.
We are on this 2000 branch.
Let's go back to master.
So get switch master and on master.
It's very simple.
We have two commits and that's it.
And we can see that head is referring to master because we're on the master branch and the master branch
is pointing to this commit.
This is the most recent commit on the tip of the master branch.
Let's take a look at this commit hash.
It starts with 93e.
Let's just remember that 93ed 93 OC.
So remember that.
And now remember we have this hidden directory called Git and inside of it I'll just seed inside seed
dot git.
We have this thing called head and head.
If I take a look I'm just going to use the cat command is referencing this other thing refs slash heads
slash master.
</h3>
<h3>
So in other words this is I'll simplify it head is pointing to the master branch if I switch branches
get switch oldies whoops can't do that from here.
I have to back out now if I switch because I was in the docket directory, gets very confused, get
switched to oldies and now I take a look again.
So I'll do cats dot git slash head.
I'm now outside that folder.
See this?
It now references oldies.
So if I switch back to Master.
And I take a look at head.
It's now master.
So that thing, that file called Head is just referencing a particular branch.
Now this thing here, refs slash heads slash master or refs slash heads slash oldies right here.
They actually reference a particular commit.
</h3>
<h3>
So let's take a look.
I'm going to open up the docket directory now.
I've opened up the git directory just in finder here and let's take a look at this.
Refs slash heads slash master.
So refs heads and you'll see there's a file for every branch that I have.
And in each one of these files, there's just one thing.
I'm going to open it in my text editor.
It's just a commit hash it's just a pointer to a particular commit and head in turn is pointing to one
of those branch references.
So remember head was reps, slash heads, slash master.
That's what it had inside.
And then if we look at what that actually is.
It's a comet 93 E RD.
That is where the master branch left off.
That's where the bookmark for master branches.
Now, if I switch to the oldest branch, nothing changes in this master reference.
Right.
But we know that my head changed so we could take a look at that again.
Cat dot get slash head.
There it is.
Head slash oldies and if we look at that.
All this.
It says the last commit on the oldest branch is seven FD and if we type git log, that's exactly what
we see.
Seven FD.
Right, so we can see that all over the place.
I have this 2000 branch and it says the last commit on there zero to F four OC.
And so if we switch to that branch get switch two thousandths.
Typekit log.
There it is.
There are 2f4.
So each one of these is like a bookmark.
It's one of these branch references.
</h3>
<h3>
So we happen to have what, five of them instead of two?
In this diagram, each one refers to a commit.
It just stores that commit hash in a file and then head changes.
This file right here changes depending on what we have checked out, which branch we're currently on.
So again, this really doesn't matter if you understand it or not.
In terms of using Git, it's not a big deal as long as you understand the fact that head is just whatever
you're currently checked out on, whatever you're what branch you're on.
But behind the scenes, this is the mechanism.
It's just a file and it references a particular branch reference.
We look at those branch references, they in turn refer to a particular commit.
</h3>
<h3>
So pretty simple when you look at it this way.
So hopefully this diagram plus this starts to sort of congeal branch reference points to a commit,
this one points to a different commit head, just points to one of those branch references so we can
stay on dark mode or I could toggle back to master, but these stay the same.
The branch reference, they both stay the same head is all that's changing until I do more work and
make new commits anyway.
So the optional I'm sure I'm boring you to death, so I'm going to stop.
</h3>
<h2>===================</h2>
<h2>MERGING BRANCHES</h2>
<h2>===================</h2>
<h3>
    In this section we'll see how we merge branches, and there are 
    different types of merges, here's an overview of each section 
    based on importance.
</h3>
<h2> Critical importance:
    <ul>
        <li>Fast Forward Merges</li>
        <li>Git Merge and Merge commit commands</li>
        <li>Resolving merge conflicts</li>
    </ul>
</h2>
<h2> Nice to know but not critical:
    <ul>
        <li>
Using VsCode to resolve conflicts
        </li>
    </ul>
</h2>
<h3>
    Now let's get into it, how do we merge branches, an essential 
    thing we must learn, to do this we use the git merge command
</h3>
<h3>
    This is a common part of git workflow especially when working 
    on a team, you're going to be using git merge frequently 
    in a developer role. 
</h3>
<h3>
    So a big thing to know is that we don't ever experiment 
    merging with master until a feature is 100% approved to 
    merge back to master branch, you'll leave master alone 
    until your "feature branch" or branch you're editing 
    has been completely fleshed out and approved for a merge.
</h3> 
<h3>
    So everyone at X company works on their own unique 
    feature branch, your co-workers will have their own 
    branches that they're editing for a specified task same 
    as yourself, then maybe you'll merge branches at some 
    point.
</h3>

<h3>
    Remember we merge branches themselves, not commits, and we always merge 
    to the current HEAD branch
</h3>
<h3>
    When we want to merge, we follow these steps:
    <ol>
        <li>
            Switch into the branch you'd like to merge the changes 
            into(the receiving branch) using git switch command: git switch 
            master
        </li>
   <li>
    Use the git merge command to merge the changes from a specific branch 
    into the current branch, which from above would be master: git merge bugfix

   </li>
    </ol>
So it's essentially: git switch into the branch you want to merge changes 
into, then once inside the selected branch, use git merge bugfix or git merge + 
branch name we want to merge into master
</h3>
<h3>Okay so it does work, going to merge into master again</h3>
<h2>
    Testing out the fast forward merge in git
</h2>
<h3>
    So right now I'm in a new branch, not master, these last few lines from 
    1100 to 1105 are unique to this branch so let's merge these changes 
    into Master, let's try it out now
</h3>
<h3>
    Keep in mind not all merges are fast forward merges, for example if 
    someone made changes to master before you did, then you try to merge 
    your branch to master... well master's been changed since you were 
    last there, so now there's new info there, so Git may not be able 
    to do this automatically for us, we will need to resolve these conflicts.

</h3>
<h3>
    The easier way of doing this is through VsCode since it has a handy 
    dandy input that'll display when merge conflicts arise, we could also 
    manually go into the files and make the changes so that Git will merge 
    without conflicts, but utitlizing VsCode seems to me, at least right 
    now, to be the easier of the two.
</h3>
<h3>
    Okay so the exercise went well, I completed all of colts challenges,
    successfully generated a FF(fast forward) merge, generated a merge 
    without conflicts, and generated a conflicted merge and resolved it.

</h3>

<h2>Intro to Git Diff, how we compare changes with git diff</h2>
<h3>Most of the following commands will be important but 
    not critical, git diff might come up a couple times a day 
    in the average developer workflow, unlike things like git add, commit ,
    branch etc.. those are the bread and butter.
</h3>
<h3>Critical:
    <ul>
<li>
    Reading diffs
</li>
<li>
    Git diff basics
</li>
</ul>
</h3>
<h3>
    Important:
    <ul>
        <li>
            Diffing branches
        </li>
        <li>
            Diffing commits
        </li>
        <li>
            Diffing specific files
        </li>
        <li>
            Git diff --staged
        </li>
    </ul>
</h3>
<h2>
    Intro to Git Diff
</h2>
<h3> We use the git diff command to view changes between 
    branches, commmits, files, directories and more! 
    We often use git diff alongside git status and git log, to 
    understand and get a better picture of a repository, and 
    how it's changed over time.
</h3>
<h3>Git diff is purely an informative command, it's about 
    understanding changes, and how they have changed.
</h3>
<h3>What's the output of git diff and what does it mean? </h3>
<h3>Well git diff always follows a very similar pattern,
    it shows the changes made since the last commit, it's usually 
    highlighted in green with a '+' or '-' sign in git bash.
</h3>
<h3>
    Now lets look at git diff HEAD
</h3>
<h3>
    so git diff HEAD, so we may see the same changes as git diff, but 
    this changes when we add a file to the staging area, once we add 
    the file with git add, when we input git diff, it'll show nothing 
    because the file's been added to the staging area
</h3>
<h3>But if we input git diff HEAD it will show the changes even 
    though our file has been added to the staging area
</h3>
<h3>
    So the takeaway here is that git diff shows the staged changes, and 
    git diff HEAD shows all changes, staged and unstaged.
</h3>
<h3>
    Another way we can use git diff is with: git diff --staged and 
    git diff --cached, they do the exact same thing --staged is an 
    alias of --cached, but they show 'Show me what will be 
    included in my current commit'
</h3>

<h3>
    We can also narrow down git diff with the command git diff [filename]
    If there's a specific file you want to see changes is you can 
    input the command like this: git diff HEAD style/main.css
</h3>
<h3>
    This will show the changes made inside the main.css file
</h3>

<h2>Comparing changes between branches</h2>
<h3>We can also use git diff to compare changes 
    between specified branches, the command looks like:
    git diff branch1..branch2
</h3>
<h2>
    The last comparison we'll look at is using git diff 
    to compare commits. To compare two commits the command 
    looks like: git diff commithashone..commithashtwo
</h2>
<h3>
    So in essence to compare two commits, we need to copy 
    the hash of a given commit, and the hash of the other commit 
    and add them to our git diff commithashone..commithashtwo
    command
</h3>
<h2>Using a GUI to visualize git diff</h2>
<h3>
    Using a GUI like GitKraken to visualize Git Diff, definitely very 
    useful when working with large files
</h3>
<h3>
    Okay I just finished colt's git diff exercise, went well, I forgot 
    about the git diff --cached command, but got through the exercise 
    without trouble.
</h3>
<h2>Intro to Git Stash command</h2>
<h3>Some people don't use git stash frequently, but it's helpful 
    to learn about git stash, but you may not use it all the time.
</h3>
<h3>Important:
    <ul>
        <li>Git stash basics</li>
        <li>Git stash save</li>
        <li>Git stash pop</li>
     </ul>
     <h3>Nice to have but not vital:</h3>
     <ul><h3>
<li>Git stash apply</li>
<li>Dropping an clearing the stash</li>
     </ul>
     </h3>
</h3>
<h2>Why is git stashing a thing? What does it solve?</h2>
<h3>
    Git stash is useful when you don't want to make a full commit, 
    but you need to go somewhere else, change branches, coworker asks 
    for help etc.. 
</h3>
<h3>
    Git provides an easy way to stash uncommitted changes so we can return 
    to them later without having to make unnecessary commits
</h3>
<h3>
    The command itself is: git stash, and this will take all uncommitted 
    changes and stashes them. In the event we don't want to commit but 
    we also don't want to lose anything, we use git stash, then we can 
    move to whichever branch we need because our changes are stashed
</h3>
<h3>
    Then once we want to reinstate our stashed changes we use the command 
    git stash pop
</h3>

<h2>
    Git stash apply command
</h2>
<h3>
    Git stash and git stash pop are the most common stash commands 
    but git stash apply is another command we can use
</h3>
<h3>
    Git stash apply behaves similarly to git stash pop, except with apply, 
    the changes are simultaneously inside the stash and applied, where 
    as git stash pop clears the stash, git stash apply applies the changes 
    but still has the stashed data inside the stash
</h3>

<h3> 
    It's important to know we can stash multiple times, with multiple
    changes. We can view our stash list with the command: git stash list
</h3>

<h3> We can also use a specific stash based on it's unique id, 
    which looks like: git stash apply stash@{2} 
</h3>
<h3>
    We can also drop stashes with the command git stash drop stash@{2}
    we can drop particular entries within our stash with this command:
    $ git stash drop stash@{0}
Dropped stash@{0} (a95a8d099dd503aacb5f9e700acc151b132dc1d8)

</h3>
<h3>
    We can also use the commmand git stash clear, to clear out all 
    stashed items
</h3>
<h2>
    Git stash exercise
</h2>
<h3>
    # Stashing Exercise

1. Initialize a new git repo in a folder
2. Create a file called `diary.txt`.  Inside the file, add the following:
    
    ```
    I love my boss
    ```
    
3. Add and commit the changes on the `master` branch
4. Create a new branch called `the-truth`.  Switch to it.
5. In the `diary.txt` file, erase the contents and instead replace it with:
    
    ```
    I HATE MY BOSS
    I HATE MY BOSS
    I HATE MY BOSS
    I HATE MY BOSS
    I HATE MY BOSS
    ```
    
6. Save the file
7. **OH NO!** Your boss is walking towards you! Quick, switch over to the `master` branch!
8. **WHATTT?** The `diary.txt` file still contains our confession?  **Quick, stash the changes before your boss sees!!**
9. Your `diary.txt` file should now only contain "I love my boss"
10. As your boss walks by, add more lies to the `diary.txt` file:
    
    ```
    I love my boss
    I love my boss
    I love my boss
    ```
    
11. Add and commit your changes on the `master` branch.
12. Now that your boss has left, it's safe to get back to the truth! Switch over to the `the-truth` branch.
13. Retrieve the earlier changes that you stashed (I HATE MY BOSS x 5)
14. Add and commit the changes on the `the-truth` branch
</h3>

<h2>====================================== ======================</h2>
<h2>KEEPING FILES LOCAL TO EACH BRANCH, WE MUST ADD AND COMMIT</h2>
<h2>=============================================================</h2>
<h3>Note to self, if we create a branch off of main/master, master has one file: index.html,
    let's say we create a branch called test ,
    then we switch to test and inside of test we create a new file; test.txt,
     if we switch back to main/master, that 
    file comes with us, and if we ls it will show 
    both index.html and test.txt, 
     If we want to leave the file on the test branch, and keep it separate from 
     main/master we must commit the changes to the test branch first, then 
     switch to master/main. I wanted to create this note because I kept 
     wondering why these branch specific files were moving across branches,
     it's because the added files must be added and committed to the 
     branch they are on before switching branches, otherwise they'll 
     come along for the ride
</h3>



<h2>
    Undoing changing and time-traveling in Git
</h2>
<h3>
    This next section is a motley crue of git commands, 
    we'll be going over a few commands you may not use 
    everyday
</h3>
<h3>
    Critical:
    <ul>
        <li>
            Checking out commits
        </li>
        <li>
            "Escaping detached HEAD"
        </li>
    </ul>
</h3>
<h3>Important:
    <ul>
        <li>
Discarding changes with checkout
        </li>
<li>
    Git restore
</li>
<li>
    Git reset
</li>
<li>
    Git revert
</li>
    </ul>
</h3>
<h2>
    Checking out old commits
</h2>
<h3>
    We're going to go back to git checkout, we can use git checkout 
    to look at a specific commit hash with the command:
    git checkout + hashnumhere, git checkout d8194d6
</h3>
<h3>
    After entering the above, a message appears: "You are in a 
    'detached head' state, you can look around, make experimental changes, 
    and commit them, and discard any commits you make in this state, 
    without impacting any branches by switching back to a branch
</h3>
<h3>
    After entering git checkout 37ed289, we now only see 4 commits, versus 
    the 10 or so commits when we first did git log --oneline inside 
    our repo, we traveled back in time.
</h3>
<h3>Head usually points to the branch reference, and the branch reference 
    points to the most recent commit on the branch, but when we use git checkout 
    plus a hash num, we detach the head from master, and head is now 
    pointing to the specified commit hash num
</h3>

<h2>
    Re-attaching our detached head
</h2>
<h3>
So in this state we can see and examine the contents of the old 
commit, we can leave and go back to where we were and re-attach the 
HEAD, or we could create a new branch, switch to it and make/save changes 
because after creating and switching branches, our head is also 
now re-attached.

</h3>
<h3>
    So we saw that we can check out a particular commit using a commit hash.
But there's another way in get that we can reference other commits.
We can reference things based upon head.
</h3>
<h3>
The syntax is kind of it's a little weird, but it looks like this head and then a tilde, which is
usually above the tab key and then a number.
So head tilde one is actually going to refer to whatever commit comes before.
Head Think of it as head minus one head.
Tilde two it's whatever comes to commits before head the grandparent commit.
So if this is where head is, if I check out head.
Tilde one It's the previous commit head.
Tilde two is this commit three is this one so I don't use this all that often, but sometimes if you
have a reason to reference what you did in the last commit and you don't want to go look up that commit
hash, you can still very easily reference it with head tilde one So I'll show that very quickly on
our master branch.
Just take a look.
</h3>
<h3>
So we've got big in chapter three.
That's where we are right now.
If I just want to go back one commit, I could copy this.
Right, and then check that out or I can do this.
Get check out.
Head.
Tilde one not 21, just one.
</h3>
<h3>
And once again, we're back to detach Head, because we checked out a particular commit.
This is just a different way to reference that commit, right?
We just said the previous commit, but it still commit.
We're not on a branch and we see that here.
Head is now pointing to this commit add headings to all files.
So before head was pointing to master which is still pointing to this commit.
Now head is one before and what we see in our file we probably won't notice a whole lot, but there's
no chapter three.
That is the difference.
Chapter one and chapter two are here, but chapter three was the next commit.
It still exists on Master, of course.
</h3>
<h3>
So from here, if I want to go back one commit again, I can just do the same command get check out
head minus or tilde one because head is now right here.
I can still reference one commit prior.
And now we go back one one further.
So there we are.
Head is now here.
And we can see we don't have those headings in my files anymore. Chapter two. Chapter one.
They used to have a heading up top, and that's kind of all I want to show.
 I'll switch back to Master now.
Get switch, master.
</h3>
<h3>
And now we have those headings back and we have Chapter three back.
So we're back up to date with the Master Branch reference.
One other thing that we can do to get back to the branch we were on, so let me try and explain that
in a better way.
If I check out some commit, I go into detached head.
Right now I'm on master, right?
So if I check out head Tilde, I don't know.
Let's go way back like eight.
We're way back here.
This commit here.
Now, if I want to go back to where I was, I want to leave detached head.
One option is to just remember what branch I was on.
Master, and go back to Master.
Get switch master.
The other option is get switch with a dash and that will just take me back to whatever branch I was
on last.
And that happens to be master.
But I could show a different example, right?
We have this other branch.
I already forgot the name.
What is it?
Chapter two redo.
If we check that out or switch to it.
Either one.
That's where I was.
Now I'm going to go back, get check out head.
Let's do Tilde one.
So I'm on this branch.
I'm going to go back one commit.
And now I just want to leave.
Detached head.
I don't remember what branch I was on or I'm just lazy.
I do get switched dash and it takes me back to where I left off.
 That's all I wanted to show.
</h3>
<h2>Discarding changes with Git Checkout</h2>
<h3>
    Okay so colt just made a new repo, with two files: dog.txt and 
    cat.txt, first we initialized the repo, then one by one added 3 
    commits, all saying: first commit, second, and third, one line 
    at a time
</h3>
<h3>
    This is to demonstrate how we could use git checkout to 
    revert changes or discard changes back to an earlier version of 
    a file
</h3>
<h3>We can do this with the command: git checkout HEAD file-name</h3>
<h3>In our example it would be: git checkout HEAD dog.txt</h3>
<h3>We're telling git take the contents of dog.txt at HEAD,
    and get rid of/discard the changes we made. </h3>
    <h3>And yes it works, cat.txt and dog.txt were reverted 
        to their original state, the changes I made are gone
    </h3>
    <h3>Another way to do the same thing is with the 
        git command: git checkout -- cat.txt dog.txt
    </h3>
    <h3>So git checkout HEAD dog.txt and git checkout -- dog.txt 
        do the exact same, just different ways of using the same 
        command
    </h3>
    <h2>
        Intro to GIT RESTORE command
    </h2>
    <h3>
        This is a new command in Git, and it helps us undo operations, 
        keep in mind we just saw git checkout -- filenamehere command 
        discard changes, but git checkout does a ton of different things, 
    which is why git restore was introduced, similar to how git switch 
    was also added as an alternative to git checkout 
    </h3>
<h3>
    We use git restore to unmodify files, in case you changed and saved a 
    file, but don't want those changes to stay, you can use git restore,
    be cautioned though, after entering the git restore command, there's 
    no going back, the uncommitted changes are permanently gone, use 
    git restore with utmost certainty you want to discard changes made.
</h3>
<h3>
    And yes git restore does work, after entering the command, 
    all the changes I made are gone, and the file is back to the 
    state in which I made the last commit
</h3>
<h3>
    Now remember this command has the exact same result as git checkout 
    HEAD dog.txt, it's just simpler
</h3>
<h3>
    We could also go back further in our commit history with this command: 
    git restore --source HEAD ~2 dog.txt
</h3>
<h3>
    the ~2 or ~num is specifying how many commits to go back, we could go 
    back 3 commits with ~3
</h3>
<h2>Second use of git restore</h2>
<h3>We can also utilize git restore to remove files from 
    the staging area, if you accidentally use git add on 
    a file by mistake we use the following command: git restore 
    --staged file-name
</h3>

<h3>So in summary we can use git restore filename to discard changes, and 
    we use git restore --staged file-name to unstage an added fike
</h3>
<h2>
    Undoing commits with git reset command
</h2>
<h3>
    So in case we want to undo a commit, we can use git reset git-hash-num 
    to undo them, be warned though, after entering the commits are gone
</h3>
<h2>
    Intro to git revert
</h2>
<h3>
    Another similar sounding command, that also will undo changes, 
    except git revert hashnum, will leave a trace of the deletion, 
    when we use git reset/restore, those commits are gone without 
    any evidence of deletion, but git revert will leave evidence 
    of the deletion, the history is preserved.
    </h3>
    <h3>
        This is useful when working on a team, using git reset 
        causes problems when working with others, they may need to 
        see the commit that was deleted, which is why using git 
        revert instead is best practice
    </h3>
    <h3>
        Okay just finished the git restore/revert exercise, got through 
        it okay, seems easy enough
    </h3>
    <h2><u>
        Intro to GitHub</u>
    </h2>
    <h2>Critical:
        <ul>
        <li>
      What does GitHub do?
        </li>
        <li>
            Cloning
        </li>
<li>
    Registering to GitHub and setting up SSH keys
</li>
<li>
    Creating GitHub repos
</li>
<li>
    Working with remotes
</li>
<li>
    Git push
</li>
    </ul>
</h2>
<h2>
    What does GitHub do for us?
</h2>
<h3>
    GitHub is a hosting platform for git repositories, 
    you can add your repos to GitHub and access them on any computer 
    anywhere, as well as share them.

</h3>
<h3>
    GitHub also provides additional collaboration features not native 
    to git, but are very useful, in essence GitHub helps people 
    share and collaborate
</h3>
<h3>
    Also gitbub is the home of open source projects, this is a good way 
    of getting experience working on a project with others.
</h3>
<h3>
    GitHub can help show that you know how to work/collaborate on things, 
    it can be a good way of showing to potential employers that you 
    know how to collaborate well, and know how to help with 
    projects
</h3>
<h2>
    Cloning
</h2>
<h3>
We use git clone to go and get a repository that's not on your machine 
and brings it to your machine. Basically downloads the contents of a 
repo from a url

</h3>
<h3>
    The command itself is: git clone https://GitHub.com/blah
</h3>
<h3>
    Also keep in mind we can also clone a repo from any website that has 
    a public repository, for ex on Gitlab there are some public repos 
    to clone, instead of a GitHub url, it would be gitlab.com/randomrepo 

</h3>
<h2>
    SSH Config
</h2>
<h3>
    SSH stands for Secure Shell, and an ssh key is used for authentication, 
    for things like pushing to a repo from your local machine, your terminal 
    will prompt you for your GitHub email/password every time unless 
    you set up your SSH key
</h3>
<h2>
    Creating a repo
</h2>
<h3>
    If you have repo you'd like to push to GitHub, here are 
    the steps:
</h3>
<h3>Option one:</h3>
<ol>
    <li>
        Create a new repo on GitHub
    </li>
    <li>
        Connect your local repo (add a remote)
    </li>
    <li>
        Push your changes to GitHub
    </li>
</ol>
<h3>
    Option two if you've not done work on your local repo yet:
</h3>
<ol>
    <li>
    Create new repo on GitHub
    </li>
    <li>
        Clone it down to your machine
    </li>
    <li>
        Do some work locally
    </li>
    <li>
        Push changes back up to GitHub
    </li>
</ol>

    <h2>
        Remote
    </h2>
    <h3>
        The next thing we need to do is take an empty GitHub repo, and 
        configure it so that it knows about our local repo, we do this with 
        a remote, like a destination url, like a label, so we can fetch code
    </h3>
    <h3>
        To view any existing remotes you may have you can use the 
        git remote or git remote -v (v stands for verbose, use for more 
        info) if we haven't added any remotes, it will display nothing
    </h3>
<h3> 
    We use the command: git remote add name url, a standard name 
    is git remote add origin https://GitHub.com/blah/repo.git
</h3>

<h3>
    We can also rename / remove our remotes with the following commands:

</h3>
<Ul>
    <li>
        git remote rename "name-here" "new-name-here"
    </li>
    <li>
        git remote remove "name-of-remote-to-remove"
    </li>
</Ul>

<h2>
    Intro to pushing
</h2>
<h3>
    Now that we have a remote set up let's push some stuff to 
    GitHub, to do this we use the git push command
</h3>
<h3>
    We must specify the remote we want to push up to AND the 
    specific local branch we want to push to the remote
</h3>
<h3>
    The command is: git push "remote-name" "branch name",
    for this repo it would be git push origin master
</h3>

<h2>The next few lines are direct copies of the transcript of 
    colt's video
</h2>
<h3>
    Okay.
So let's talk about how we actually get our code up on GitHub.
How do we take a local git repo on our laptop?
And how do I connect that in some way to a hosted GitHub repo?
How do I connect them?
How do I set up the repo on GitHub?
And then what do I do on my machine to tell it about the GitHub repo?
Well, there's really two different approaches or two options that I'm going to walk through in this
video.
I'm just going to talk about both of them and just explain how they work and then we'll dive into actually
doing them.
</h3>
<h3>
So the first option called option one is if you have an existing repo on your machine, if you have
something that you've already been working on, it already has git history, you already have code,
whatever it is, and you want to get that on GitHub.
These would be the steps that you follow.
You create a new repo on GitHub, then you connect your local repo by adding something called a remote.
We'll go into that.
So you add that remote to your local machine and then you push your changes up to GitHub.
So here's some diagrams.
</h3>
<h3>
If I have something I've been working on, whether it's just a day of work, an hour of work, an empty
repository that I've created or years of work, whatever it is, if it's on my machine and not on GitHub,
I go on to GitHub and I make a new empty repository.
I'll show that in just a moment to.
So once I make that new empty repository, then what I do is tell my computer.
Specifically tell this git repository about the GitHub repository.
And then I can push my code up to the GitHub repo.
The other option is if I don't have anything done yet, I don't have a repo anywhere.
I know I want to start a project and I know right out of the gate that I also want to use GitHub alongside
Git.
If that's the case, I can start on GitHub, make a new repo on GitHub and clone that down to my machine
as an empty repository.
</h3>
<h3>
Instead of running git init I can clone down my GitHub repo that's empty and start working in that repo
and then push it up to GitHub.
And if I do it that way, I don't have to manually connect my local repo to my GitHub repo because if
I clone this repo from GitHub, it automatically is connected to that GitHub URL.
So some diagrams to illustrate that.
I don't have any repositories yet either on GitHub or on my machine.
And I start by making a new repo on GitHub, which I'm visualizing is this empty container, and then
I clone that down to my laptop.
And because it came from this clone, it automatically knows about this GitHub URL.
So now I can do my work locally and push it up.
I don't have to connect them in any way, but I'm going to actually start by showing you the other option.
Option one, because you may have some existing code.
I mean, we certainly have existing repos from the course.
None of them are very useful, but we have existing repos.
Right.
</h3>
<h3>
We've been working with Git and let's talk about how to get that on GitHub.
So to do that, the first step is to make an empty GitHub repo.
So if you want to follow along, start by just picking some git repository that we've made or that you've
made that you want to get on GitHub.
So it doesn't have to be something that you make public and it doesn't have to be something that you
keep up there, right?
You can delete it or get rid of it immediately if you don't want people to see it.
</h3>
<h3>
So we've done quite a few different repositories.
Why don't I just take that really simple book repository?
My first novel.
All right.
So it's a disastrous repo.
I'd like to get all of this up on GitHub.
All right.
All this history, all my files.
One more time.
This is what I'm dealing with.
So whatever you have found, if you have a repo you want to follow along with, the first step is to
go on GitHub.
</h3>
<h3>
So once you're signed in and create a new empty repo and there's a couple of buttons to do that, one
is just this green button if you're on the home page new or if you're somewhere else like I'm on Marketplace.
If I click the plus new repo right there, then I see this page create a new repository.
So we need to come up with a name about GitHub, demo, novel or something like that.
This is just a name that we'll use to identify it on GitHub, right?
It doesn't have to match anything from our actual repository that we have locally, but we don't want
spaces.
It will automatically add dashes for us.
I don't know, I just put them in there myself.
But we don't need to do that.
</h3>
<h3>
You don't really need a description, although you should put one in, especially if you plan on having
other people see this repo or discover it.
But we will talk more about that to keep this short and simple.
I'm not going to put a description in there and then we can decide if it's public or private.
Now, I'm going to keep this public in case some of you want to take a look at the repo, although,
frankly, for the contents of this book, it's probably best for my reputation if I do make it private.
That just means that if someone looks at my profile, if they search, they're not going to find this
repository.
They don't have access to it.
But if it's public, anyone can see it.
And then I'm not going to touch this.
<h3>
We will come back and talk more about these files later.
I'm just going to click Create Repository.
And did I click?
I might have not.
I guess I didn't click.
And we now see this page here.
So my username, Colt Slash and then the repository name, and then inside of it.
There's not really anything to look at right now except for a couple of instructions.
All right, so I'll stop here.
We've made an empty GitHub repository.
Our local repo knows nothing about it.
They're not connected in any way, but that's going to change in the next video.

</h3>
<h2>GIT REMOTE SETUP</h2>
<h3>
    All right.
So the next thing that we need to do is take this empty GitHub repo that's in the cloud.
It's not connected at all to our local repo and somehow configure our local repo so that it knows about
this GitHub repo.
</h3>
<h3>
Well, the way that we do this, whether we're using GitHub or any other service that hosts the repo,
is to set up a git remote.
So a remote is really just a fancy name for like a destination URL.
It's a URL that we tell get about and we give it a name.
It's just like a label for a URL that we can then push code up to or fetch or pull down new code from.
</h3>
<h3>
So we'll learn about those commands once we set up a remote.
So an easy place to start is with this command git remote or get remote dash v.
They won't do anything except list to you the current remotes that you have in a repository.
So in our repository we have not configured any remotes.
Right?
At this point.
We haven't done anything with remotes.
If I type git remote or git remote V, I'm in my book, my first novel, The Great Gatsby repo nothing.
But if we actually go to any of the repos that we cloned, if you follow a followed along, I cloned
this 2048 repo from GitHub.
Remember this one it has a whole bunch of commits it's that addicting 2048 game anyway if I type get
remote in here I see something now origin we'll talk about that in a moment.
</h3>
<h3>
Let's do dash v so you can see the difference.
If I do dash v, I think it's verbose.
We see the name of of a remote and the corresponding URL.
So I didn't set this up right.
All I did was get clone and then this URL and by doing that get made me a local repo.
It put all these files in here, it gave me all the history and it set up a remote that said the original
GitHub URL that this repo came from, that it was cloned from IS right here.
So by setting this URL up, this remote origin, it gives me the ability later on to say, Hey, Git,
is there any new code on that URL?
Is there any new updates?
Or if I was a collaborator, hey git, I'd like to push up my new ten commits.
</h3>
<h3>
It's kind of a lot to push up, but I'd like to push my new two commits that I did today up to Origin.
So I'll just show you one more example.
If I take a look at that see sample project that was the one that I cloned in the second video I did.
It's really very simple.
Nothing in it.
It came from was it Bitbucket?
I believe if I do get remote V No, git lab.
Sorry, it was a non GitHub repository.
The same thing is true.
Right.
I have a remote called origin automatically set up.
I didn't do that and it set to whatever I cloned or whatever the URL is that I cloned it from.
Okay.
So we did not clone this repository, right?
My first novel, we we ran getting it.
We created it from scratch.
So there are no remotes, but we can make a remote using this command, get remote add and then a name
and a URL.
So this is a way of telling git hello gets.
Please remember this URL using this name.
So whatever the name is that we provide.
So a really standard name is origin.
</h3>
<h3>
So get remote, add origin and then some GitHub URL for a GitHub repo that we've created is telling
git.
Hey, here's a URL, I'm going to call it origin.
You remember that anytime I refer to origin, I'm talking about this URL.
So the term origin, it's just a conventional git remote name, but it's not special in any way.
No magical powers.
It doesn't have any secret abilities.
It's just a name for a URL you could rename them.
You can come up with whatever names you want for remotes, but origin is what you'll see all the time,
similar to how the master branch is a default name or the default name for branches, you can change
it to anything.
So in the same way that master is just a name for a branch origin.
It's just a conventional name.
You'll see it a lot, but it is not somehow special.
It's just a name for a remote.
</h3>
<h3>
So we could instead add a new remote for the same URL, but instead call it my GitHub URL or lol or
chickens are my friends, whatever you want, but I would suggest origin because it's what you'll see
the most and then a URL.
And actually if we go to the GitHub repository that we created that's empty, we see some instructions.
It's telling us, first of all, if you've done this thing before, this kind of thing before, here's
a URL that is the URL for my repo.
I hope this goes to that.
Saying you should be using your URL, right?
</h3>
<h3>
Not my repo because you won't have permission to push your code up to my repository.
So I hope you made your own.
If you're following along then it's telling me if you don't have a repo yet on the like at all locally,
follow these instructions.
But I do.
So I'm not following those.
This is what we want.
Push an existing repo from the command line and take a look at the very first line.
Get remote, add origin and then the URL for my git repo.
It's the same URL we see here, so I'm going to copy that or just copy the whole line.
It doesn't really matter.
I guess I'll separate it out just to hit the point harder here.
So I'm on the my first novel repository right now.
No remotes now get remote add and then a name.
I'm going to go with origin.
It's conventional.
</h3>
And then this GitHub URL, whatever your GitHub URL is for that repo.
Now nothing really happens.
But of course we can check our work with what we just saw get remote v.
So hopefully we see origin set up to this URL and it is.
So that's kind of all we need to do for now.
We've connected.
We've told our local git repo about a GitHub URL called Origin or that's the name that will refer to
it by.
<h3>
So in the next video, I'll show you how we can push code up to origin.
I just want to emphasize one more time, it's just a name for a URL, a remote destination, and this
is not super common, but if needed you can rename a remote with this command, get remote, rename
the old name, space, new name and you can get rid of a remote with git remote remove and then the
name that you're trying to delete.
And later on we'll actually see that it's somewhat common to have multiple remotes, especially when
you're working on open source projects.
We'll talk about workflows and how that would work when we get to that section.
</h3>

<h2>Intro to Git Push</h2>
<h3>
So we have one more step to get our code up on GitHub.
We just need to push it up.
So if you remember option one, what we're following here.Option one out of two is to create a new repo on GitHub, which we've done.
Connect the local repo by adding a remote to our GitHub repo.
We just did that in the previous video.
Now we need to push our changes up so we have our existing repo.
I'm doing that stupid Great Gatsby novel fake repo.
I created an empty GitHub repo and then I set my remote called Origin so that it points at this empty
GitHub repo.
So the final step is to push up.
So we do this using the git push command.
</h3>
<h3>
Again, this is not GitHub specific though.
Everything will be pushing to will be a GitHub repo, but the get push command is a git command that
existed long before GitHub.
And there are many other places where you can have a hosted repo that you can push to.
So it works with any remote.
Basically the syntax is git push and then a remote.
</h3>
<h3>
In our case we just have one which is origin, but we can have multiple.
So we have to tell git where we're pushing, what's the destination repository and what branch to push.
So, you know, we might have a really large repo with a ton of branches.
Like actually we don't have a ton here, but we've got a couple.
No, just to.
Oh, well, this is because this video or this repo was created before we went into branching.
But some of our repos have like, I don't know, seven, eight, maybe ten branches and you may not
want all of them on GitHub or you may not want to push them all at once at least.
So when we push, we call out a particular branch that we want to send to GitHub.
Often that will be your master or main branch, but you can push any branch up to GitHub and I'll show
you that.
<h3>
So this is a really common command to get Push Origin Master, though it is becoming slightly less common
as more people rename their master branch to Main.
If you recall, we talked about this early on when I introduced branching.
It now comes up again Master versus Main because GitHub, as I mentioned at the end of 2020, decided
to make the default branch name on a GitHub repo main instead of master.
So their instructions tell you to add a remote called Origin, but then rename your branch the master
branch to Main and then push Main.
So I will do this as well.
In a separate video I will show this process.
It's the exact same process.
We rename a branch, we name it main, and then we push up Main.
But I'm going to start with Master, just to keep this as simple as possible, because we have a master
branch, right?
</h3>
<h3>
We've been working with the term master, so we'll start there first.
So I have this remote called origin as we already discussed, get remote dash v, we see what it's pointing
to and it's always a good idea to see what what we have, if we have any uncommitted changes that won't
go up otherwise we're ready.
We're going to do a git push and then origin is where we're pushing to and then master is the branch
we are pushing up.
Okay, so this is what our GitHub looks like right now.
I'll refresh.
There's nothing here except these instructions.
This is the repo.
But now I'm going to push and there's going to be a substantial change.
And remember.
</h3>
Oh, gosh, I put images in this repo, didn't I?
Well, that's why it's taking a little bit.
So you can see here I have some images in that mood board.
Usually you don't include images in a or at least not large images like I have, but it finished up.
Most repos are going to push way, way, way faster than that because they're usually just code.
So I'm going to refresh the page.
And now we see something entirely different.
Right.
We don't see those instructions.
Now we see our file contents.
So chapter one, chapter two, chapter three, characters outline.
We see different commits.
I'll actually do a separate video where I walk through what we see, but we also have access to things
like contributors.
We can see there's only one branch which is the master branch, and I can take a look at chapter one.
For example, here's the contents of Chapter one.
</h3>
Okay.
So we have our code up here.
Now, what I want to show you is that we can push any branch.
I talked about pushing master because that's what we have on this project.
But if we make a new branch, which I'll just make, what should my branch be called?
How about empty or nearly empty?
I switch to that branch and I'm just going to delete pretty much everything in here.
I'm going to delete Moodboard for sure.
So that's actually our m dash ref to get rid of that.
It's a folder.
And erm.
How about all chapters?
Chapter one.
I'll just leave the outline and the characters.
So now, whoops, this is all we have.
I'm on a branch, though, called Empty, so I'm going to add everything and then get, commit, delete
most things.
All righty.
</h3>
<h3>
Now, if I want to push the code that I just changed, I want to push my last commit from this branch.
Remember, I'm on the empty branch.
I need to push the empty branch.
So let me illustrate that here.
I've got some diagrams.
What we just did was we pushed up our master branch to GitHub.
So there was nothing on GitHub.
I pushed up master.
Whoops, I went to far get push origin master assuming our remote is named Origin.
Now in this diagram, I have a second branch called New Feature.
I'm going to push that up.
Get Push Origin new feature.
In our case, our branch is called empty.
So get push origin empty.
I don't have to be on this branch, by the way.
I happened to be on it, which is very common that you're taking a look at what's on a branch and then
you push it up, but you don't have to be on it.
So get push origin empty.
And remember, if it asks you for your password, not a big deal.
It put your email and password or your username and password, but go back and check out the SSH video
so that it doesn't have to keep bugging you, you know, asking you for a password every time you push.
</h3>
<h3>
Okay.
So now I'm going to refresh.
And it doesn't look like much changed.
But now we have two branches and we can see the two branches here, master and empty, and I can switch
between them.
And this is my empty branch.
I'm just viewing it on GitHub and you'll see it just has two files.
Right?
Go back to Master.
And I have a whole bunch of stuff.
So I'm going to just go through this process one more time, just to make it very clear, I'm going
to go back to Master, get switch master and let's make some some changes.
We'll do some new work here.
How about chapter four?
Dot txt.
All righty.
And I'll just leave it blank, I guess.
And I'm going to add that.
So get ADD Chapter four, get commit.
Begin Chapter four.
</h3>
<h3>
Pop quiz.
What's on my GitHub?
What's the most recent comet that I'll see on the GitHub repo?
Nothing has changed on GitHub.
It's still exactly the same.
If we're looking at the master branch, nothing's changed.
If we're looking at the empty branch, nothing has changed since we last pushed.
GitHub doesn't just stay in sync automatically with my local repo.
I have to push.
So why don't I push up that commit?
Chapter four begin chapter four.
Now I said push up that commit.
We don't select a specific commit.
We push an entire branch as we've talked about.
So I made that commit on the master branch.
So I'll push that up, get push origin.
The only remote we have right now.
Origin Master.
Now, if we head over here and refresh, we see first of all, my most recent commit begin chapter four
one minute ago.
We also see the actual updated contents.
Right.
Chapter four text is right there.
Okay.
So in the next video, I'm going to kind of walk through a GitHub repository, show you how we view
the commits, the branches, diffs or changes, all that stuff.
And then we'll get some more practice with pushing and we'll talk about renaming to use the main branch.
</h3>

<h3>Okay so I made a branch off master called testgitpush, 
    switched to that branch, then made a change, added/committed, 
    git status to make sure tree is clear, then did git push origin testgitpush 
    and GitHub updated, now it has a dropdown menu showing both master branch 
    and my new testgitpush branch
</h3>


<h2>
    The next section is more practice with git push. It went well, I did 
    more practice with adding/deleting files/content then pushing those 
    changes to GitHub, and seeing GitHub update with those changes 
    in real time.
</h2>
<h3>
   So colt just went over how we can push a local branch up to a different 
   branch at the same time, example: 
</h3>
<h3>
    git push remotename local-branch:remote-branch
</h3>
<h3>The exmaple colt uses is with a pancake branch thats local 
    and a waffle branch that's remote, it's not very common but the 
    point is that it's possible. git push origin pancake:waffle
</h3>
<h3>Another example </h3>
<h3><ol>
    <li>
        git switch -c "cats" (this creates and switches to a new branch called 
        cats)
    </li>
    <li>
        touch cats.txt
    </li>
    <li>
        git add cats.txt
    </li>
    <li>
        git commit -m "create cats file"
    </li>
    <li>
        git push cats:master (this tells git to take the cats branch containing 
        a txt file and push it to our master branch on GitHub)
    </li>
</ol>
So we just pushed the cats branch to the master branch, this is a good 
example that shows the difference between the branch on your 
local machine and the branch one GitHub.
</h3>
<h2>
    Intro to the "-u" flag appended to the git push command
</h2>
<h3>
    "u" stands for upstream, normally we want the upstrean branch to be 
    origin master/main, running git push -u origin master sets the 
    upstream of the local master branch so that it tracks the master branch 
    on the origin repo.
</h3>

<h2>Another workflow: Cloning first</h2>
<h3>
    If you haven't yet began work on your local repo you can:
</h3>
<h3>
<ul>
    <li>
          Create a brand new repo on GitHub
    </li>
<li>
    Clone it down to your local machine
</li>
<li>
    Do some work locally
</li>
<li>
    Then push back to GitHub
</li>
</ul>
Okay so this seems pretty easy, just create an empty repo, 
copy the hash/cloning address, use the command: git clone https://GitHub.com/Colt/chickens-demo.git
Then a message pops up saying "you appear to have cloned an empty 
repo", type git status and it should say on branch main/master, and if 
we use the git remote -v command it shows we're all set up and 
ready to start making changes, we can now git add/commit/push and 
GitHub will be good to update.
</h3>
<h3>
    Also just a note, going forward we should use main instead of master 
    for our big branch, we can rename a branch with this command:
    git branch -M main
</h3>
<h3>Keep in mind we have to change the default branch 
    in GitHub settings, after I used the git branch -M main, it didn't 
    rename it, created a branch from master called main. To fully change the name 
    there is a way:
</h3>
<h3>
    Renaming Git Branch
Follow the steps below to rename a Local and Remote Git Branch:

Start by switching to the local branch which you want to rename:

git checkout old_name
Copy
Rename the local branch by typing:

git branch -m new_name
Copy
At this point, you have renamed the local branch.

If you've already pushed the  old_name branch to the remote repository , perform the next steps to rename the remote branch.

Push the new_name local branch and reset the upstream branch:

git push origin -u new_name
Copy
Delete the old_name remote branch:

git push origin --delete old_name
Copy
That's it. You have successfully renamed the local and remote Git branch
</h3>
<h3>
    I'm going to leave master and main up on this project as an example.
</h3>

<h2>GitHub basics exercise: last section on intro to GitHub, 
    going to do colt's end of section exercise now
</h2>

<h3>
    Okay so the exercise went well, up until the merge conflict, there 
    was a merge conflict that I resolved in VSCODE but when I pushed it 
    back to GitHub it showed the >>>> head >>> and the unstaged changes 
    in the push/change, I should've double checked before pushing. Exercise 
    is now done though, pretty comfortable with git push now. 
</h3>

<h2><u>Fetching and Pulling</u></h2>

<h3>In this section we'll discuss git fetch and git pull, so if we're 
    working with a collaborator. We've seen the other half with the 
git push command, but now we'll look at git pull</h3>
<h3>Here's what's critical in this section:</h3>
<ul>
    <li>
Remote tracking branches
</li>
<li>
    Git Fetch
</li>
<li>
    Git Pull
</li>
</ul>
<h2>
    A closer look at cloning
</h2>

<h3>
    When we clone a repo, whatever it is, what happens is that after 
    we clone the repo to our local machine we receive all the commits, 
    all the files from the repo, but we also receive the "remote 
    tracking branch", which is a reference to the state of the master 
    branch on the remote, we can't move this, it's like a bookmark 
    pointing to the last known commit on the master branch on origin
</h3>
<h3>
    Remote tracking branches follow this pattern: remote/branchname
</h3>
<ul>
    <li>
        origin/master references the state of the master branch on 
        the remote repo named origin
    </li>
    <li>
        upstream/logoRedesign references the state of the logoRedesign 
        branch on the remote named upstream (a common remote name)
    </li>
</ul>
<h2>
    Checking out remote tracking branches
</h2>
<h3>
    So if on our main branch, let's make changes, add and commit them 
    and now we have two commits locally on the main branch, and we see 
    something new, theres a message in git bash that says:
    On branch main
    Your branch is ahead of 'origin/main' by 1 commit.
      (use "git push" to publish your local commits)
    

</h3>
<h3>
    So if we do this again, after adding another name to our animals.txt 
    file, now we see:
    Your branch is ahead of 'origin/main' by 2 commits.
  (use "git push" to publish your local commits)

nothing to commit, working tree clean

</h3>
<h3>
    So that's the point of this, it shows how many commits are 
    since the origin/main

</h3>
<h3>
    We can also checkout what our origin/main looks like, using 
    git checkout origin/main, we'll end up in detached HEAD
</h3>
<h3>
    So let's type git branch -r to view the remote tracking branch, 
    in our case it's origin/main
</h3>
<h3>
    After entering git checkout origin/main the following message 
    is displayed:
    git checkout origin/main
Note: switching to 'origin/main'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c new-branch-name

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 10e4639 Create pets.txt

</h3>
<h3>
    We can now create another branch from this state, remember now 
    our changes to pets.txt are gone , and we're back to pets.txt 
    original state 
</h3>
<h3>
    We can now switch back to the main branch, and our pets.txt 
    file changes return, now we see reagan, maggie, and buck
</h3>

<h3>
    So if we want those changes to go onto GitHub, we just push 
    them with git push origin main,
</h3>
<h3>I'm having some problems pushing to GitHub, 
    im changing my config from [core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[user]
	name = Luke
	email = lrsorrenti@yahoo.com
[remote "origin"]
	url = git@GitHub.com:LRSORRENTI/GIT-GitHub-COLT-STEELE.git
	fetch = +refs/heads/*:refs/remotes/origin/*

</h3>
<h3>
to the user email - lrsorrenti@hotmail.com, let's see if this works.... it didn't.
</h3>
<h2>Okay so half-hour and lot's of googling later I got to a stack overflow answer, 
    to fix the above problem where is says user name of my old GitHub luso8 is denied.
    I don't understand exactly why it was letting me push yesterday and earlier today 
    then suddenly stopped, but after going into windows credentials manager and 
    deleting the luso8 credentials, git push now works, what's also confusing me 
    is why is LRSORRENTI not showing up in that windows credentials page? 
    Wait no I just checked, the credentials before were luso8, my old GitHub, now it says 
    the credentials are set to LRSORRENTI, hopefully this is the last time I'll need to do this,
    maybe there was an easier way of bypassing the credentials problem through git, but hey 
    it works now so let's get back to the course.
</h2>

<h2>
    NEXT SECTION: WORKING WITH REMOTE BRANCHES
</h2>
<h3>
    For ex, if we have a repo we want to clone, that has many different 
    branches on GitHub, how do we work with those branches locally
</h3>
<h3>
    So colt has a remote-branches demo repo we're going to clone, after 
    cloning we type git branch and we see only one branch, main, even though on 
    GitHub we saw that this specific repo has 5 or 6 branches
</h3>
<h3>How do we work on the other branches then?
Well we can view the remote branches with git branch -r command, we see all 
the branches we couldn't see with just git branch, so 
git knows about those branches, so that's why we need to discuss the diff 
between  a full-fledged branch and a remote tracking branch
</h3>
<h3>
    By default, when we clone a repo from GitHub, we get the main/master 
    branch, and automatically it's pointing to origin/master, but 
    we have other branches in our case it's origin/movies, origin/food, origin/fantasy 

</h3>
<h3>
    Let's say we want to work on a branch called puppies, what we could 
    do is use checkout origin/puppies, but remember that puts us into 
    detached HEAD state, 
</h3>
<h3>
    Lets do git checkout origin/food, after entering it displays the 
    "you are in deteched HEAD state", but now we can see the files 
    inside of our food branch, 
</h3>
<h3>
    Let's say I want access to these branches, we can use the git switch 
    command + remote branch name to create a local branch of that remote 
    branch so we can work on it
</h3>
<h3>
    And yes this does now work, when I type git branch main AND food 
    now show up as accessible branches locally
</h3>
<h3>
    Now let's do the same for the remote movies branch, so from main type 
    git branch -r to view all remote branches, we see movies is a remote 
    branch, then type git switch movies, and voila we now have the remote 
    movies branch local to our machine
</h3>
<h3>
    Note: git switch is clutch in this regard, in the past we 
    would need to type git checkout --track origin/movies in order 
    to achieve the same as git switch movies, so more concise
</h3>

<h2>
    Git Fetch THE BASICS:
</h2>

<h3>
    Let's talk about fetching and pulling, fetch and pull are 
    two commands we can use to get changes down from 
    GitHub, if you're working on a team, and someone makes/pushes 
    changes, we use git fetch to pull those changes down from 
    the remote repo (GitHub) and it fetches them to our local repo,
    just the local repo though, fetch does NOT bring the changes 
    all the way to our current workspace, that's what git 
    pull does. 
</h3>
<h3>
    The git pull command will bring changes down from our remote 
    repository (GitHub) and bring them all the way down to our 
    workspace.
</h3>
<h3>
    So fetching allows us to download changes from GitHub, BUT 
    those changes will not automatically integrate into our workspace,
    it let's you see what your teammates have been working on 
    and the changes they've made, without having to merge those changes 
    to your local repo
</h3>
<h3>
    Think of git fetch as "hey, please go get the latest info from 
    GitHub, but don't integrate it into my working directory"
</h3>

<h3>
    The command itself is: git fetch origin, or git fetch remotenamehere 
   If a remote is not specified after git fetch, it will automatically 
   fetch origin
</h3>
<h3>
    We can also use git fetch origin master or git fetch origin branchName 
    to fetch a specific branch
</h3>
 
<h3>
    A good way to think of it is, let's say your teammate Bob made 
    3 changes to the remote repo, we can use git fetch to bring those 
    changes down and view them without directly altering our 
    working directory, those changes will not automatically change 
    our working directory, we can view them and see what Bob has 
    done to the project
</h3>
<h3>
    So once we use git fetch origin master, in order to view those 
    changes we pulled down from GitHub we use: git checkout origin/master

</h3>
<h3>
    Okay so the exercise went well, except when I added an apple.txt 
    file on a different branch from master, then used git fetch, it wasn't 
    showing up, I think it's because I didn't use git checkout, I used 
    git switch
</h3>
<h3>
   </h3>
   <h3> Okay so I tried again but this time used this answer from stack overflow,
    git checkout origin/yourbranchname -b newbranchname
git log newbranchname
You should see remote changes in the newbranchname.

You can also merge those changes into your branch with

git checkout yourbranchname
git merge origin/yourbranchname
</h3>
<h3>
    After entering the above I was able to view the changes I made on 
    a new branch. 
</h3>


<h2>
    Git Pull
</h2>
<h3>
    git pull is another command we can use to retrieve changes, except 
    with pull it will integrate those changes, and immediately update 
    our working directory, think of it as a git fetch + git merge all ine 
    one go. As opposed to git fetch where we can view the changes, but our 
    working directory stays the same.
</h3>

<h3>
    The syntax is similar to fetch it's: git pull remote branchname 
    so it would look like git pull origin master, so it would 
    both fetch the data changes AND integrate in one command
</h3>
<h3>
    Keep in mind where we run git pull matters, whatever branch 
    we're on, that's where the changes will be merged to
</h3>

<h3>
    Pulls can also result in merge conflicts, and we'll need to resolve 
    them like a normal merge
</h3>
<h3>
    Okay so after using git pull, a message in git bash popped up 
    asking for a commit message as to why the merge was necessary, so I googled 
    it and came across this answer:
</h3>
<h3>
    Type the subject of your commit on the first line. Remember to keep it short (not more than 50 characters). 
    Leave a blanagraphs and bullet points to give a detailed breakdown. 
Don't write everything out on one line, instead, wrap text at 72 characters.
Press Esc and then type :wq to save and exit.
</h3>
<h3>
    Then after entering esc and :wq the changes from GitHub, two ascii art files were fetched and 
    merged into my working directory
</h3>

<h2>
    Git Pull Merge Conflicts
</h2>

<h3>
    Pulls can result in merge conflicts,  sometimes we'll get a 
    fast forward merge and things go smoothly, but if changes were 
    made on GitHub, then we try to pull, a merge conflict may appear
</h3>

<h2>
    Shorter syntax for git pull
</h2>
<h3>
    Often when we use git pull, we can get away with a shorter syntax:
    git pull
</h3>

<h3>
    If we run git pull without specifying a particular remote/branch to 
    pull from, git assumes the following:

</h3>
<ul>
    <li>
        Remote default to origin
    </li>
    <li>
        Branch will default to whatever tracking connection is 
        configure for our current branch
    </li>
</ul>

<h3>
    Note: This behavior can be configured and tracking connections can be 
    changed manually. Most people don't mess with this stuff
</h3>

<h2><u>GitHub grab bag: Odds and ends</u></h2>

<h2>Critical:</h2>
<h3>
    <ul>
        <li>
            Repo visibility: Private vs Public
        </li>
        <li>
            Adding GitHub collaborators
        </li>
        
    </ul>
    Important:
    <ul>
        <li>
            README files
        </li>
    </ul>
     Nice to have: 
     <ul>
        <li>
            Writing markdown
        </li>
        <li>
            GitHub Gists
        </li>
        <li>
            GitHub pages
        </li>
     </ul>
</h3>

<h2>
    GitHub repo visibility: Public vs Private
</h2>

<h3>
    On GitHub we can make the visibility of any repo public or private,
    when we create a repo, GitHub will prompt you to make it public or 
    private.

</h3>

<h2>
    Adding GitHub collaborators
</h2>

<h3>
    When we add collaborators, we allow others to be able to push 
    changes to the given repo, when a repo is public, anyone can take 
    the repo and clone them, make changes/commits, but they can't 
    push those changes back up to GitHub
</h3>
<h3>
    To add a collaborator, inside of our repo settings, we can go to 
    the 'manage access' tab, and add direct access collaborators, we 
    then enter the persons GitHub user name/ email, then all that 
    person needs to do is accept the invite and voila, collaboration
    is now enabled between you and that person
</h3>
<h2>
    The GitHub collaboration demo
</h2>
<h3>
    Okay in colt's demo he's showing two users collaborating on a 
    project, first user is Colt, second user is Stevie,
    Colt initializes the repo, adds some text to the file, 
    then pushes the file to GitHub
</h3>
<h3>
    Then Stevie clones the repo, sees the text inside the file, adds 
    some extra text to the file, then pushes back to GitHub

</h3>
<h3>
    Now Colt can see stevie pushed some work to GitHub, there are 2 commits 
    now, so Colt can use git pull, or git fetch, to bring those changes down 
    to his machine
</h3>
<h3>
    That's the basic GitHub collaboration workflow, you and your teammates ,
    make changes, push them to GitHub, then you can bring those changes 
    to your machine with git pull or git fetch
</h3>

<h2>What are READMEs and why they're important</h2>
<h3>
    A README file is used to communicate important information about 
    a given repository including:
</h3>
<h3>
    <ul>
        <li>
            What the project does
        </li>
        <li>
            How to run the project
        </li>
        <li>
            Why it's noteworthy
        </li>
        <li>
            Who maintains the project
        </li>
    </ul>
</h3>
<h3>
    READMEs play an important role, it's often the first 
    thing someone looks at when they're viewing your project, and if you put 
    the README.md in the root of your directory, GitHub 
    will display it automatically
</h3>
<h3>
    For reference the .md stands for 'markdown', markdwon files are 
    convenient syntax to generate formatted text, and it's easy to use
</h3>

<h3>
    Markdown itself is a 'text to HTML' conversion tool for web writers,
    markdown allows you to write and easy-to-read, easy-to-write plain 
    text format, then convert it to structurally valid XHTML or HTML
</h3>

<h3>
    Markdown is not specific to GitHub, people use markdown all over 
    the place, there are tools to write and render markdown yourself, 
    VSCode extensions, standalone applications
</h3>
<h3>
    Check this link for full guide to markdown: https://markdown-it.GitHub.io/
</h3>
<h3>
    So just like HTML there are headings: h1, h2, h3, h4, h5, h6,
</h3>
<h3>
    For an h1 we write the markup with a '#' followed by space, then our text,
     for h2 it's two '#' , for an h3  it's 3 '#' and so on
</h3>
<h3>
    Okay so now I'm going to create a README for this file
</h2>
<h3>
    Okay just created a basic README file, added and pushed it to 
    GitHub, added the link from above there as well, it's a great 
    guide to creating visually appealing README files

</h3>

<h2>GitHub Gists</h2>
<h3>
    GitHub gists are a simple way to share code snippets and 
    useful fragments with others. Gists are much easier to create 
    but offer far fewer features than a typical GitHub repository
</h3>
<h3>
    All we need to do is use .html, .js, or .md and the gist will 
    show it as a HTML file, JS file or README.md file
</h3>
<h2>
    GitHub Pages
</h2>
<h3>
    What are GitHub pages? GH pages are public webpages that are 
    hosted and published via GitHub, they allow us to create a website 
    by simply pushing your code to GitHub
</h3>

<h3>
    So we can easily host webpages on GitHub, there are restrictions, 
    it DOES NOT support server-side code like Python, Ruby, or Node.
    Just HTML/CSS/JS! Static webpages only. It's free and it's built into 
    GitHub itself
</h3>
<h3>
    There are two types of GitHub pages:
</h3>
<h3>
    <ul>
        <li>
            User Site
        </li>
        <h3>
            You get one user site per GitHub account, this is where 
            you could host a portfolio site or some form of personal 
            website, the default url is based on your GitHub username,
            following this pattern: username.github.io, though you 
            can change this
        </h3>
        <li>
            Project sites
        </li>
        <h3>
            You get unlimited project sites! Each GitHub repo 
            can have a corresponding hosted website. It's as simple 
            as telling GitHub which specific branch contains the 
            web content. The default urls follow this pattern: 
            username.github.io/repo-name
        </h3>
    </ul>
</h3>

<h3>
    Now let's demonstrate how to create a GitHub page, 
    from your project, go to settings, navigate down to pages, 
    select build and deply from whichever branch you want to display, then 
    after a minute or two it loads and it will display: 'Your site is 
    live at username.github.io/projectname'
</h3>
<h3>
    Github has great documentation to getting everything set up, 
    so for future reference looking at their documentation will 
    help set up your github hosted static webpage
</h3>
<h2>
    Git collaboration workflows
</h2>

<h3>
    What matters in this section:
</h3>
<h3> Critical:
    <ul>
        <li>
          The problems with working on a single branch
        </li>
        <li>
            Feature branch workflow
        </li>
        <li>
            Pull requests (Very Critical!)
        </li>
        <li>
            Forking
        </li>
        <li>
            Fork and clone workflow
        </li>
    </ul>
</h3>
<h3>
    Important:
    <ul>
        <li>
         Branch protection rules
        </li>
    </ul>
</h3>

<h2>
    Centralized Workflow, what is it?
</h2>
<h3>
    Centralized workflow is when everyone works on master/main, it's 
    the simplest workflow to have everyone work on a single branch, 
    it's straightforward but has quite a lot of shortcomings!
</h3>

<h3>
    Let's look at an example, we have 3 collaborators: Pamela, David, 
    and Forrest. 
</h3>
<h3>All three of them clone the main/master branch of the github repo to their 
    local machines
</h3>
<h3>
    Forrest works on a new feature all day, adding and committing all 
    day long, let's say he has 2 total commits on the master branch, so he 
    then pushes it up to GitHub
</h3>
<h3>
    Pamela has also been working on a new feature, as she's been 
    working Forrest pushed some code up, but now Pamela's done 
    and wants to push her code up
</h3>
<h3>
    So she tries git push and the following error message is 
    displayed: 'Failed to push. Updates were rejected because the 
    tip of your current branch is behind it's remote counterpart. Merge 
    the remote changes (e.g. 'gitpull') before pushing again
</h3>
<h3>
    So she does that, she uses git pull to get the changes from the 
    origin master. Forrest's work must be merged in. Hopefully this goes 
    smoothly! There may be conflicts, there may not be. But she has 
    to do it in order to push back up to master/main.
</h3>
<h3>
Now during all of this, David is working on a new feature but is 
having some doubts, he'd like to share his commits with 
the rest of the team to start a discussion, he's made a lot of changes 
and things aren't working properly, so he wants to discuss with the 
team.
</h3>

<h3>
    David can't simply push his code up to share it, Pamela tried that 
    as well and needed to pull Forrests changes down first, merge those 
    changes and then push
</h3>
<h3>
    Before he can even share his incomplete/problematic code, he needs 
    to pull and merge from GitHub, then push his work up. THEN everyone 
    can pull his work down, and he may have broken the codebase 
    if this actually happens, depending on how problematic 
    his code is
</h3>
<h2>
    The problem:
</h2>
<h3>While it's nice and easy to only work on a single branch, this 
    leads to serious issues when working on a team!
    <ul>
        <li>
         Lot's of time spent resolving conflicts and merging code, especially 
         as team size scales up.
        </li>
        <li>
            No one can work on anything without disturbing the main 
            codebase. How do we add something radically different in?
            How do we experiment then?
        </li>
        <li>
            The only way to collaborate on a feature together, with another teammate
            is to push incomplete code to main/master, resulting in a broken 
            codebase
        </li>
    </ul>
</h3>
<h2>
    Colt's Centralized worlflow demonstration
</h2>
<h3>
Colt just did a demo of why branching is important, if we work 
on a team of many different collaborators, having all of 
them working, making changes to, and pushing on the same 
branch is a huge headache. Which is why we dont't work on the 
master/main branch, enter FEATURE BRANCHES
</h3>
<h2>FEATURE BRANCHES</h2>

<h3>
    Never work directly on master/main, all work/new development 
    needs to be done on separate branches!
</h3>
<h3>
    <ul>
        <li>
    Treat the master/main branch as the official project history 
        </li>
        <li>
            Multiple teammates can collaborate on a single FEATURE 
            branch, and share code back and forth on that branch 
            without messing with master/main
        </li>
        <li>
            Master/main will NEVER contain broken/unfinished code 
            (or at lest it won't until someone messes it up)
        </li>
</ul>
</h3>
<h3>
    Just created a FEATURE branch, going to leave my main/master 
    branch alone, then merge
</h3>














































</body>
<script src="script.js"></script>
</html>