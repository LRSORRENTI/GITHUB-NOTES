<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>GIT_AND_GITHUB_COLT-STEELE</title>
</head>
<body>
    <header class="header"><u>COLT STEELE GIT-GITHUB NOTES</u></header>
    <div class="myIntro">
    <h1>I am going to be taking notes with this html page,
        this is colt_steele's intro to git/github,
        I have a little experience since I did THE ODIN PROJECT
        FOUNDATIONS, but I know I need to practice
        and retain more in regards to version control, so this is just going to
        be notes for myself.
    </h1>
    <h1>
        Here's a list of tags that will take you to specified 
        points in the html page
    </h1>
    <ul>
        <li><a href="course_gameplan">Course gameplan</a></li>
    </ul>
    </div>
    <div>
        <h2>So git and github are the most widely used version
            control tool across programming, so for a new developer
            the best time to learn and become familiar with Git is 
            yesterday, it's that important. It's going to be very important
            to start using and living Git, it takes a lot of practice
            so we'll start using it for all our learning projects going forward.
            I'll need to incorporate it in my next and current colt steele course
            which is the web develormper bootcamp/ react bootcamp, I'm already halfway 
            through colt's complete javascript bootcamp so i'll utilize git from now 
            until the end of that.
        </h2>
    </div>
    <div>
        <h1>THE COURSE GAMEPLAN:</h1>
        <h2>
            <a id="course_gameplan"></a>
        <ul>
            <li>Educational (Hopefully)</li>
            <li>Entertaining (When possible)</li>
            <li>Interactive (Lot's of exercises!)</li>
            <li>Visually interesting (Tons of diagrams)</li>
        </ul>
        </h2>
    </div>
    <div>
        <h1>
The course cirriculum:
    </h1>
    </div>
    <div>
        <h2>
<ol>
<li><h2>Intro to git</h2></li>
<li><h2>Installation</h2></li>
<li><h2>Git Basics</h2></li>
<li><h2>Committing in detail</h2></li>
<li><h2>Branching</h2></li>
<li><h2>Merging</h2></li>
<li><h2>Diffing</h2></li>
<li><h2>Stashing</h2></li>
<li><h2>Undoing changes</h2></li>
<li><h2>Github intro</h2></li>
<li><h2>Fetching and pulling</h2></li>
<li><h2>Github odds and ends</h2></li>
<li><h2>Collaborative workflows</h2></li>
<li><h2>Rebasing</h2></li>
<li><h2>Interactive rebasing</h2></li>
<li><h2>Git tags</h2></li>
<li><h2>Git behind the scenes</h2></li>
<li><h2>Reflogs</h2></li>
<li><h2>Custom aliases</h2></li>
<li><h2>???</h2></li>
</ol>
        </h2>
    </div>
    <div>
       <h1>So not all of the above are part of the git core,
        the git core of this bootcamp are the first six of the above
        ordered list:
</h1>
<div>
    <ul>
       <li><h2>Intro to git</h2></li>
        <li><h2>Installation</h2></li>
        <li><h2>Git Basics</h2></li>
        <li><h2>Committing in detail</h2></li>
        <li><h2>Branching</h2></li>
        <li><h2>Merging</h2></li>
</ul>
</div>
    </div>
    <div>
        <h1>
            Then after we go over the core of git we'll look at
            what colt calls "next level git":
        </h1>
        <ul>
            <li><h2>Diffing</h2></li>
            <li><h2>Stashing</h2></li>
            <li><h2>Undoing changes</h2></li>
        </ul>
    </div>
    <div>
        <h2>The above don't come up nearly as often as the git core</h2>
    </div>
    <div>
        <h1>
      Now we move onto the next 4 which is Github and collaboration:
    </h1>
    <div>
        <ul>
            <li><h2>Github intro</h2></li>
            <li><h2>Fetching and pulling</h2></li>
            <li><h2>Github odds and ends</h2></li>
            <li><h2>Collaborative workflows</h2></li>
        </ul>
    </div>
    </div>
    <div>
        <h1>
           So in the above section we go over github pages and github gists,
           and collaboration workflows, different structures and strategies
           some developer teams employ using github
        </h1>
    </div>
    <div>
<h2>So after the above we get to the final section which is just a mixture of
    other git stuff, some of it is more niche but still important, some of
    the stuff you may never use, but it's important to understand the use
    cases for what they can provide to a developer
</h2>
<div>
    <ul>
        <li><h2>Rebasing</h2></li>
        <li><h2>Interactive rebasing</h2></li>
        <li><h2>Git tags</h2></li>
        <li><h2>Git behind the scenes</h2></li>
        <li><h2>Reflogs</h2></li>
        <li><h2>Custom aliases</h2></li>
    </ul>
</div>
<div>
    <h1>Next up let's go over how the exercises of the course work,
       these are important to fully immerse yourself with git, so doing
       them is a requirement, it's about the workflows. Practice is a must,
       it's not optional.
    </h1>
</div>

<div><h1><u>INTRODUCING..... GIT!</u></h1></div>
<h1>So the main takeways in this section are:
    <ul><li>What is git?</li></ul>
    <ul><li>Difference between git and github</li></ul>
    <ul><li>What does git do for us</li></ul>
</h1>

</div>

<div>
    <h1>What is git?</h1>
    <div>
    <h2>Git is the worlds most popular version control system (VCS)</h2>
    <h2>Version control is software that tracks and makes changes to files
        over time, extremely important, most VCS allow users to revisit earlier 
        versions of files, compare changes between versions, undo changes
        and much more
    </div>

    <div>
<h2>
Git is just one VCS, there are many others like Subversion, CVS, and Mercurial,
they all have similar goals but we mainly use git because git is the clear
winner, in a survey 88.4% of developers use git day to day
</h2>
    </div>
   
    </div>
    <div>
        <h1>Now let's discuss what exactly git does for us</h1>
        <h2>Git helps us:
            <ul><li>Track file changes</li></ul>
            <ul><li>Compare versions of a project</li></ul>
            <ul><li>"Time travel" back to earlier versions</li></ul>
            <ul><li>Revert to a previous version</li></ul>
            <ul><li>Collaborate and make changes</li></ul>
            <ul><li>Combine changes</li></ul>
            Git facilitates collaboration
        </h2>
        <h2>Think of it like separate save files in the Witcher 3
            or any game with separate save states, you can travel back
            to when you first started the game if you made these "checkpoints"
            or saves, and we can even merge our save states depending
            on our goals.
        </h2>
        <div>
            <h1>Linus Torvalds is the creator of Git, he created it himself, 
            he wanted Git to be free, not a paid DVCS
        </h1>
        </div>
    </div>
    <div>
       <h1>Huge companies use Git, companies like Google, Netflix,
         Microsoft, Twitter, and even governments make use of git,
         Washington DC city council utilize git.
         </h1>
    
    </div>
<div>
    <h1><u>Git Vs. Github</u></h1>
    <div>
        <h1><u>Git</u></h1>
        <h2>Git is the VCS that runs locally on your machine,
            you don't need to register an account. You don't need
            internet to use Git, you can utilize git without
            ever even touching Github
        </h2>
        <div>
            <h1><u>Github</u></h1>
            <h2>Github is a service that hosts git repositories (repos)
                in the cloud and makes it much easier to collaborate 
                with others. You do need a Github account to use Github,
                It's a place to share work done using Git on your local
                machine
            </h2>
        </div>
        <h1>We're going to start with Git in this course then 
          move to Github
        </h1>
    </div>
</div>
<div>
    <h1>The next section we go over installing and setting up Git</h1>
</div>

<div>
    <h1><u>Installing Git, terminals vs GUI's </u></h1>
<h2> We're going to start with the command line first then
    we'll use a GUI to see what that's like, the GUI we're 
    going to utilize later is: GitKraken
</h2>
<h2>GitKraken is free and it's the GUI that colt recommends</h2>
</div>
<div>
    <h1><u>TERMINAL CRASH COURSE</u></h1>
    <h2>In this section I'm going to run through some of the 
        essential terminal commands for navigation for
        moving around on your machine.
         We need this in order to work with Git.
         Commands like ls and pwd, and cd: 
    
    <ul>
        <li>"start ." command - this command will open the file explorer 
        of whatever directory you're inside of
    </li>
</ul>

<ul>
<li>
    "ls" the ls command will display all files currently inside of the PWD or
    present working directory, we can also use ls with a folder name to display
    whats inside of a selected folder like "ls 'Pictures'" or "ls 'Desktop'"
</li>
</ul>

<ul>
<li>
    Anyway, the next command I'll show you is pretty simple.
It's called 'pwd' for print working directory.
And what this will do, it's very simple.
It just prints out your current location.
It prints out the path to where you currently are.
</li>
    </ul>

    <ul>
        <li>So to our next command which is 'cd' (change directory) it's the 
        equivalent of changing folders in file explorer. So to change directories
        we can go from something like /Desktop to /Desktop/GIT_AND_GITHUB_COLT-STEELE
        by using the cd command followed by the directory name so the above would be:
        cd /GIT_AND_GITHUB_COLT-STEELE
    </li>
</ul>
<ul>
    <li>
        Now let's look at how to move 1 directory backwards. So if we're stll inside
        /Desktop/GIT_AND_GITHUB_COLT-STEELE, we would do 'cd ..' cd followed
        by two dots .., now we're back into just /Desktop
    </li>
</ul>
<h1><u>Terminal Crash Course: Creating Files & Folders</u></h1>
<h2>To create a new file we use the 'touch' command followed
    by the name we want to assign to the file so for ex:
 ////   touch index.html style.css script.js ////
 so after we run that command three files will be created inside
 of whichever directory we are in, an html, css, and javascript file
</h2>
<h2>
    Now lets look at how to create folders or directories, the 
    command is: mkdir myDirectory // so we now created a directory called
    myDirectory and if we cd into it we can create more directories inside 
    of it, or just create files, or both. mkdir is just a way to organize
    files. You can have directories inside of directories and even more directories
    inside those with files inside all of them. It's a good way to organize
    your files.
</h2>
  </h2>
  
 <h1><u>Terminal Crash Course: Deleting Files and Folders</u></h1>
 <h2>To delete a file we use the command 'rm' followed ny the name
    of the file. Remember this fully deletes the file it doesn't just
    send it to the recycling bin like using delete on the Desktop
    would, after using 'rm' the file is fully gone, so be careful with this
    command.
 </h2>
 <h2>
    Now keep in mind we can't use the 'rm' command to delete directories,
    instead to delete full directories we must use 'rm -rf' command,
    so it's just rm with the -rf flag after followed by the directory name
     (rm -rf testDirectory), this would delete the testDirectory 
 </h2>
 <h2>
    We can add flags to a lot of commands, one is ls -a, that command
    will display all files including hidden files, so -a modifies the 
    behavior of ls
 </h2>
 <h1><u>Git Repos</u></h1>
 <h1>What really matters in this next section</h1>
 <h2>We're going to go over what git repos are, and we'll learn 'git init',
    'git status' commands, we'll also go over the git folder and what's 
    inside of it, the Committing workflow, an important concept to 
    incorporate into your daily coding routine, we'll also discuss three 
    more commands 'git add', 'git commit', 'git log', these are very important
    commands, so practicing them is crucial
 </h2>
 <h2><u>Repository</u></h2>
 <h2>A git 'repo' is a workspace which tracks and manages files
    within a folder, anytime we use Git with a project, app, etc we need to
    create a new git repo or Repository, we can have as many repos as 
    we need, all with separate histories and contents
 </h2>
 <h2>So just because we have git installed doesn't mean we're
    automatically using it, we have to tell git we're creating a new
    Repository, it's a unique workplace with it's own history, each
    repo is like encapsulated bubbles. 
 </h2>
 <h2>For example if we want a repo inside a specific folder 
    or directory we must tell Git: Ok I want a repo inside this directory.
    And whatever commands I run are specific to that repo.

 </h2>
 <h2>Now that we know what repos are in general, let's
    go over how to intialize a new repo using git, but first let's go over
    the 'git status' command, and the 'git init' command 
 </h2>
 <h2>
    <ul>
<li><h2>'Git Status' Command</h2></li>
<h3>The 'Git status' command will give us info about the current repo,
    if there's a repo the command will return something like: "On branch 
    gitdemo nothing to commit, working tree clean"
    if there isn't a repo in the specified location 'git status' will
    return an error
</h3>
<li>
   <h2>'Git init' Command</h2>
</li>
<h3>
    So when we use 'Git init' whatever folder or directory we are inside
    will become the location of a new git Repository, keep in mind
    we only ever run 'git init' once per project, so if we had a 
    project myWebsite, we use 'git init' at the beginning, and we 
    could work on myWebsite project for years and years, we only
    use 'git init' once at the start of a git repo, we want that continued
    history.
</h3>
 </ul>
</h2>
Now there is a hidden file/folder that is created when we use git init,
for example if we type 'ls -a' inside our current directory it shows 
the following: ./ , ../ , .git/ , index.html , style.css, script.js
<h2> We can even cd into the .git folder and it will
   show things like: 'HEAD', 'config', 'description', 'hooks', 'refs',
   'info', 'objects', we can also delete the .git folder but beware, this
   deletes the repo entirely, rm -rf .git, the .git folder is where
   everything is stored, that's why it's a hidden folder, so you don't
   accidentally delete or mess with it.
</h2>
<h1><u>Common early git mistakes</u></h1>
<h2>
   So it's important to understand when we initialize a git 
   repo, anything nested inside the directory that we intialize with
   'git init' is tracked, so you could have folders inside of directories,
   inside of directories inside of more directories, all that is tracked
   if we use 'git init' in the parent directory, it tracks every file change
   all the way down.
</h2>
<h1><em><u>WARNING! DO NOT INIT A REPO INSIDE OF A REPO,
   BEFORE RUNNING GIT INIT, USE GIT STATUS TO VERIFY
   THAT YOU'RE NOT CURRENTLY INSIDE A REPO
</u></em></h1>
<h2>We want to keep our repo's separate, because it can cause
   problems later on, avoid this. Just make sure to always use
'git status' to double check </h2>
<h1><u>The committing workflow overview</u></h1>
<h2>
   What is committing? Committing is using checkpoints or  like saves
   in a video game, you add a nav bar then commit, then change something,
   else and commit that change, on and on. Like in a game you can make 
   a save early on, then revisit that early save after some time so see
   a previous version of your character. We can undo commits, revisit early
   commits, merge commits.
</h2>
<h1><u>Git add/commit command</u></h1>
<h2>
   This is the first command we use when we want to make a commit,
   the workflow is usually like:
   <ol>
       <li>Work on stuff, make new files, edit or delete files</li>
       <li>Add the changes with 'git add', where we group
           specific changes together in preparation of committing,
           now the files we specify to add are now in the staging area
       </li>
       <li>Commit the changes with 'git commmit', Commit
           everything that we just added with 'git add', now the files
           that are in the staging area are commited, usually followed by 
           a commmit message 'git commit -m  "message here"', the message should
           summarize the changes made concisely

       </li>
   </ol>
</h2>
<h2>To reiterate when we commit we always include: git commit -m "message here"
   with a massage as descriptive and concise as possible
</h2>
<h2>
    Also to add multiple files to the staging area, you would
    use the command: git add . 
</h2>
<h2>
    So (git add .) git add plus a dot at the end will stage all
    modified files, so if we changed index.html and style.css in
    in this repo then did git add . both files would be staged, but
    you could technically stage 10 modified files or 50 or 100 using
    git add .
</h2>

<h1>Git committing exercise</h1>
<h2>Okay so I just finished the git commit exercise
    and ran into a problem, there was an error being thrown 
    when I was trying to use (git add groceries.txt and yard.txt)
    after googling the error I found the fix to the problem 
    on stack overflow, to fix the error message: 
</h2>
<h2>
    Another git process seems to be running in this repository, e.g.
    an editor opened by 'git commit'. Please make sure all processes
    are terminated then try again. If it still fails, a git process
    may have crashed in this repository earlier:
    remove the file manually to continue.
</h2>

<h2>We need to cd into our .git directory then use the 
    command: (rm -f .git/index.lock) and this fixes the 
    error message, hopefully this didn't do anything 
    bad inside our .git directory but I suppose we'll
    find out later? The error did not occur in colt's 
    demonstration so I'm not sure what I did specifically
    but after deletion it worked.  
</h2>
<h1>Commits in more detail</h1>
<h2>In the next section we're going to go over the following:</h2>
<h2>
<ul>
    <li>Atomic commits (important)</li>
    <li>Configuring default editor (important)</li>
    <li>Working with a GUI (Nice to have)</li>
    <li>Amending commits (Nice to have)</li>
    <li>Git ignore (Critically important)</li>
    <li>Navigating git documentation (important)</li>
</ul>
</h2>

<h1>ATOMIC COMMITS</h1>
<h2>It's common advice to keep your commits atomic, what does 
    atomic mean? It means keeping each commit focused on a single
    change. Commit after each individual change to 
    keep things tidy and easier to problem solve. So make a 
    commit after editing text, or after implementing a css change,
    or after doing something in your JS file etc.. This practice 
    ensures an easier time identifying bugs in order to 
    preserve the work you've done that isn't problematic. Atomic
    commits make your code easier to review.
</h2>
<h2>When writing commit messages you should use present tense
    commit messages, so for ex: Writing "Make website color chnage",
    instead of "Made website color change", but I don't know, it 
    seems a little pedantic but I suppose if an employer prefers
    one or the other go with that.
</h2>
<h1>A closer look at Git Log command</h1>
<h2>We can use the "git log --oneline" to show a concise
    version of our log. This is useful and we'll go over shortly
    why it's so important. In essence it makes it easier to see
    when we need to time travel back to, which commit needs to 
    be gone back to.
</h2>
<h1>Commiting with a GUI like GitKraken</h1>
<h2>Even if you're not interested in using a GUI, learning
    about commits in GUI's are important, worth checking out. They
    help with visualizing commits.
</h2>
<h2>So using the GUI you press stage changes on the right 
    side of the GUI, then it asks for a commit message, then
press commit changes to file. This accompishes the same
exact thing as in GitBash git add, git status, git commit -m etc.. </h2>
<h2>GitKraken seems really nice, I may start using it often, I guess
    once we go over branching and merging the visualiztion of a 
    GUI can be very useful
</h2>
<h1>==============</h1>
<h1>Amending Commits</h1>
<h1>==============</h1>
<h2>Sometimes mistakes when commiting happen, so instead
    of doing a new commit we can amend previous commits using
    the --amend flag
</h2>
<h2>Keep in mind this ONLY works on the very last commit made
    you may not go back more than one commit using amend flag, 
    --amend only works on the last commit
</h2>
<h2>Okay so this --amend isn't working for me, I'm getting an 
    error message saying:
    <h2>unknown option: --amend
    usage: git [--version] [--help] [-C <path>] [-c <name>=<value>]
               [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
               [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]
               [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
               [--super-prefix=<path>] [--config-env=<name>=<envvar>]
               <command> [<args>]
               </h2>
               <h2>
               Will come back to this later to see what I'm doing wrong
               
            </h2>
<h1>=======================</h1>
            <h1>Ignoring files with /.gitignore </h1>
 <h1>=======================</h1>    
            <h2>We can tell git which directories and files
                to ignore in a given repository, we use .gitignore
                This is useful for things you know you never want to Commit
                like:
                <ul>
                    <li>Secrets, API keys, credentials etc..</li>
                    <li>Operating system files</li>
                    <li>Log files</li>
                    <li>Dependencies & packages</li>
                </ul>
            </h2>
            <h2>Typically we put .gitignore in the root of a repository
                We tell git which files to ignore, let's practice This
                by making a new directory called gitIgnoreDemo 
            </h2>
            <h2>So colt just used git ignore to ignore some json files, 
                as well as a secrets.txt file that contains a fake API key,
                and using git ignore he made it so those files did not 
                show up in gitBash so they would never be accidentally 
                added
            </h2>
            <h1>================================</h1>
         <h1><u>Working with branches in git</u></h1>
            <h1>================================</h1>
            <h1>Critical importance:</h1>
            <h2><ul>
                <li>Branching... what is it and why use it?</li>
                <h4>This is a part of git that must be mastered 
                    in order to use git day to day, learning branching
                    is vital to git workflow, branching along with 
                    commits happen daily in the life of a developer
                 </h4>
                <li>Understanding git HEAD</li>
                <h4>Also critical is understanding git HEAD, what HEAD is
                    and the fact that it points to a branch reference and that
                    reference points to a commit
                 </h4>
                <li>Git branch</li>
                <li>Git switch</l1>
                <li>Git checkout</li>
                <h4>Also crucial is understanding the branch command, the git 
                    switch command, the git checkout command
                 </h4>
            </ul></h2>
      
        
       
         <h2>Important but not crucial in this section is:
            deleting and renaming branches, and Master vs Main branch
         </h2>
         <h2>Nice to have but not super important is HEAD and ref 
            behind the scenes
         </h2>
    <h1>==========================</h1>
         <h1><u>INTRODUCING BRANCHES</u></h1>
         <h1>==========================</h1>
         <h2>Every commit has a unique hash, and each commit references 
            the commit that came before it. There is a linear history, but 
            in the real world we need to work in multiple contexts simultaneously 
            
         </h2>
         <h2>So imagine I'm working, I don't know, I work at some company, I'm working on a web application and
            I'm trying out two different color scheme variations for a website.
             And I want to try them both out and figure out which one I like best.
             And at the same time, I also have been tasked with trying to fix a really horrible bug.
             <h2>
               But this bug is proving very difficult to solve 
            I'm actually needing to delete some code and comment stuff out, move stuff around to try and hunt down
            the bug.
            So it's not as simple as just fixing a typo.
            I have to like totally destroy part of the code base to find this bug.
            </h2>
            <h2>
             And at the same time, one of my teammates is working on adding a new feature, a little chat bot and
             the bottom corner.
             You know, those things that pop up and you can chat with customer service or something.
             It's not clear at the moment if our company wants to use that, but he's going ahead and trying it as
             a bit of an experiment.
             </h2>
             <h2>
             And then another coworker is adding some new functionality to the search bar autocomplete, and yet
             another developer is doing something very different.
             She is doing a very experimental radical design overhaul of our entire application layout, but it won't
              be presented until next month and we don't even know if any of it will be used after next month.
              So lots of different contexts.
              </h2>
              <h2>
             If we all worked in a linear fashion, one commit after the next, this would be practically impossible.
             How could we be working on separate things, some of which break other people's code?
            Right.
            If I'm trying to fix a horrible bug and deleting a bunch of code, removing files, I'm just making
            a mess.
            </h2>
            <h2>
            That's going to be a big problem if somebody else is trying to add a new feature.
            Likewise, if someone is doing a radical experimental design change on every single view of our application,
            everything changes.
            </h2>
            <h2>
            But I'm trying to work on some minor color scheme variations, or if someone's working on adding a chat
            widget to the bottom right of our screen.
            Those things need to happen in separate contexts because they have implications on one another and they
            really need to happen in isolation until maybe at some point we decide to incorporate changes into each
            other's contexts.
            </h2>
            <h2>
            So that is where branching comes in.
             That's exactly what git branches allow us to do.
             Branches are a signature feature of Git and you can kind of think of them as alternative timelines for
             a project.
             </h2>
             <h2>
            They allow us to create separate contexts whenever we want.
            We can try new things.
            We can work on multiple ideas in parallel.
            We can experiment, we can break stuff, and whatever we do on one branch will not impact what happens
            on other branches, although we can decide to then combine branches, we call that merging and we'll
            learn how to do that.
            </h2>
            <h2>
            But that's something we have to decide to do.
            Otherwise, if we make a change in one branch, the other branches do not know about it.
            They exist in isolation.
            So this allows me to make a commit and maybe make another commit on one branch and then at any point
            splinter off and try something on this pink branch up top.
            </h2>
            <h2>
            I'm calling New Color Scheme.
            I could try a new color scheme out, but over here, if I switch back to this branch, none of that
            code comes with me.
            None of those new commits.
            So I could branch off again and work on a bug fix.
            </h2>
            <h2>
            But again, totally separate context.
            And then I could branch off even further from this bug fix branch and branch further to do an experimental
            redesign.
            So now I have at least four different contexts one, two, three and four.
            </h2>
            <h2>
            And this means that I could be working on this and maybe somebody else is working on this branch and
            somebody else is working here or.
            Maybe someone else is working on this purply bluish branch in the middle and working on things plotting
            ahead.
            </h2>
            <h2>
        Well, I'm still stuck here.
             We're all working in separate contexts, but then a very important part is being able to then combine
            and merge branches together when appropriate.
            </h2>
            <h2>
            If you work on a bug fix and you actually solve it, then you want to merge that bug fix into the main
            code base or into another branch.
            So we'll learn how to do all of this in time.
            </h2>
            <h2>
            But I'm going to stop talking for now.
            In this video, I just wanted to introduce this idea of branching, of having separate contexts.
        </h2>
        <h1>=================================</h1>
        <h1><u>THE MASTER BRANCH/MAIN BRANCH</u></h1>
        <h1>=================================</h1>

        <h2>
            So we're always by default on the master branch,
            we can change branches, but we'll always be 
            working on a branch, it's just the main/default 
            branch.
        </h2>
        <h2>When we first run git init on a new project/ 
            repo the default branch we always start with is 
            the master branch. Some developers treat the master/ 
            main branch as the true branch but it's really just 
            the default, you can make a different branch that's 
            not the master/main as your default that you want to work 
            with, but some devs will keep the master/main as their one 
            true branch. 
        </h2>
        <h1><i>One branch to rule them all, One branch to find them,
            One branch to bring them all, and in the darkness 
        bind them. </i></h1>

        <h2>So the master/main branch can be deleted or renamed
            or ignored entirely, it's up to the developer 
        on how they want their default or main branch to be set up </h2>

        <h2>Also keep in mind the default branch name is supposed 
            to be "Main", and not "Master", Github in 2020 renamed it 
            officially but you'll still see "master" since the change 
            was recent.
        </h2>

        <h2>It's a common workflow to set a new branch to mess 
            around and experiment with, and if it works, merge back to master 
            or keep it as a separate branch while maybe eventually merging back
        </h2>

         <h1>==========================</h1>
         <h1>What is HEAD?</h1>
         <h1>==========================</h1>
         <h2>Let's explore what (HEAD -> master) is</h2>
         <h2>HEAD is a pointer in Git, that refers to the current 
            location in your repository, it points to a specific, 
            branch reference, so far HEAD always points to the latest 
            commit you've made, but we'll see that we can move around 
            and the HEAD will change
         </h2>

  <h2> 
    Think of branches like bookmarks in a book, let's say you 
    and a few friends are reading/sharing the same book. Your 
    bookmark is blue, your friend John has a red bookmark, Jane 
    has a green one, and Mr.Smith has a teal one, at any given point 
    in time, each bookmark is unique to the person who's reading, 
    but we can view Johns branch or bookmark, or anyone who's reading 
    that same book, and the HEAD will change depending on who's branch 
    your currently viewing
  </h2>
  <h2> So to reiterate HEAD is a pointer/reference to a 
    branch pointer/reference, and a branch pointer is a 
    pointer/ reference to where the bookmark is in a book. We 
    can have many branches/bookmarks and each one has a branch 
    reference/pointer that shows where it is.
  </h2>
  <h2>So after every commit we make, we're on the same branch 
      but we can make new branches which we'll go over soon, 
      but when we switch to a new branch the HEAD follows us 
      there, Master/main branch still exists but HEAD is now 
      pointing to us, where we are with are new branch.
  </h2>
  <h2>But we can always go back to the main branch, then head will now 
    be pointing back at master/main , HEAD is just the current branch 
    we are working with.
  </h2>
<h1>==========================================================</h1>
<h1>Viewing all existing branches with "git branch" command</h1>
<h1>===========================================================</h1>

<h2>We can view all branches using the command "git branch", 
    the default branch in every repo is "Master/Main", though 
    we can change this.
</h2>
<h2>So we can type "git branch" and it shows the 
    result '* Master' since we are currently in the 
master branch  </h2>
<h2>But the * just indicates the branch we're inside of, 
    we could have four or five branches like: Master, John's bookmark, 
    Jane's bookmark, Mr.Smiths bookmark and if we're in Jane's bookmark 
    it would say * Jane's bookmark, because Jane's bookmark is 
    the branch we're currently inside, the branch w/ the asterisk 
    * next to it is our current branch.
</h2>
<h1>=================================</h1>
<h1>Creating Branches</h1>
<h1>=================================</h1>
<h2>To create a new branch we actually use the same command 
    'git branch' but we add a branch name after so it would be:
    'git branch "Johns_bookmark"
</h2>
<h2>Keep in mind we should use snake_case or camelCase 
    to name branches, avoid using spaces in branch names
</h2>
<h2>Also bear in mind when we create a branch we do not 
    automatically go inside it, we have to change branches with 
    the command git branch + branch name 
</h2>
<h2>So I just made a new branch called 'notes_branch' 
    using git branch 'notes_branch', then did git branch and 
    it was created, underneath master branch, there is my 
    newly created branch notes_branch, but keep in mind HEAD 
    is still pointing to "Master" because we have not switched 
    branches yet
</h2>
<h1>--------git switch--------</h1>
<h2>
We use the command (git switch + branch name) to switch 
to the specified branch, and voila, we're on a new branch, and HEAD is now pointing to 
the new branch
</h2>
<h2>Now when I type git status after using the command 
    git switch notes_branch it displays on branch notes_branch
</h2>
<h2>So i just did git commit -m"test new branch commit"
    this commit was made on our new notes_branch branch, 
</h2>

<h2>Now after we type git log, we see that we left the 
    master branch behind, our last commit is separate from our 
main/master branch, but like a bookmark, the master branch we left 
is still there, just as we left it, but we can switch back like we 
did before using git switch master
</h2>
<h2>And yes after switching back to master branch lines 821 to 
    839 disappeared from VsCode because this content I'm currently 
    typing is unique to this branch, the notes_branch of my 
    repo
</h2>
<h2>We're going to practice creating more branches, BUT KEEP IN MIND 
    WHERE YOU ARE/ WHERE THE HEAD IS POINTING TO WHEN 
YOU CREATE BRANCH MATTERS, if we use git branch notes_branch_two 
while head is pointing to notes_branch, notes_branch_two is a branch of notes_branch
not master, so where you use the branch command MATTERS </h2>
<h2>Okay so we just created a branch from a branch from a branch... 
    Remember notes_branch was a branch from master branch, now 
    we're inside notes_branch_two which is a branch off of notes_branch,
    which was a branch off of master. Branches from branches from 
    branches.
</h2>
<h1>============================================</h1>
<h1>git switch vs git checkout, the differences</h1>
<h1>============================================</h1>

<h1>Historically we used git checkout + branch name, and 
    it still works but git checkout does many extra things than 
    git switch, which is the reason git switch was created, 
    keep in mind you'll see git checkout used frequently 
    in older documentation/tutorials, some future co-workers 
    may use git checkout.
</h1>
<h2> So I just created a new branch then used git checkout to 
    change into it. And yes it works the asterisk is pointing to 
    my new_checkout_branch_test branch I just created
</h2>
<h2>
    So if you go to the official Git documentation there are many 
    more things git checkout does, we'll go over some of them later 
    but for now just know that git switch is how we usually 
    change branches
</h2>
<h1>==========================================</h1>
<h1>Creating and switching in one command</h1>
<h1>==========================================</h1>

<h2>We can create and switch to the newly created branch 
    with the '-c' flag right before our branch name, so it would look 
    like this: git switch -c switch_and_changed_branch
</h2>
<h2> To achieve the same using git checkout the command would 
    be: git checkout -b "branch-name-here", we use -b flag instead 
    of -c flag 
</h2>

<h2>Keep in mind if we're on a branch that's not 
    currently committed, and we try to switch, we'll get an error 
    that says "please commit or stash your changes", we'll learn 
    about stashes later but for now just know git will throw an 
    error if you try to switch without committing. 
</h2>
<h2>Also if you create a new file on your new branch, and forget 
    to commit, that file will follow you around, it won't throw 
    that error we got above, if you create a file in switch_and_changed_branch 
    then change to master branch, the file you created will follow 
    you there
</h2>
<h1>=================================</h1>
<h1>Deleting and renaming branches</h1>
<h1>=================================</h1>
<h2>We use the git branch command again but instead we 
    append the -d flag with the corresponding branch 
we want to delete </h2>
<h2> So I just switched to notes_branch_two and created 
    a new branch, then deleted it using the -d flag, I didn't 
    receive the same error colt did, Colt had an error pop up 
    that said: branch is not fully merged, run git branch -D 
    to delete, I guess uppercase -D is the force command to delete 
    branches if error messages pop up
</h2>
<h2>Let's go over how to rename branches</h2>
<h2> To rename it we use git branch + -m on the branch we 
    want to rename, yes it is the -m flag similar to 
    git commit -m for message but in this case -m refers to 
    'move/rename', Remember we have to be on the branch to rename it 
    I'm going to rename switch_and_changed_branch to switch_and_changed_branches 
    Okay it worked but we need to omit the "", using -m to 
    rename a branch, don't wrap the new name in ""
</h2>
<h1>=======================================</h1>
<h1>How git stores HEAD behind the scenes</h1>
<h1>=======================================</h1>
<h2>Okay so the below section is a direct transcript, colt goes over HEAD and how it stores hash references to commits made on 
certain branches.</h2>
<h2>
We're going to take a look at that dot git directory and I'll show you proof of head how it works.
The fact that it's just referencing a branch and that each branch reference is referencing a commit.
All right.
So let's go ahead and hop over here to our road trip playlist.
We are on this 2000 branch.
Let's go back to master.
So get switch master and on master.
It's very simple.
We have two commits and that's it.
And we can see that head is referring to master because we're on the master branch and the master branch
is pointing to this commit.
This is the most recent commit on the tip of the master branch.
Let's take a look at this commit hash.
It starts with 93e.
Let's just remember that 93ed 93 OC.
So remember that.
And now remember we have this hidden directory called Git and inside of it I'll just seed inside seed
dot git.
We have this thing called head and head.
If I take a look I'm just going to use the cat command is referencing this other thing refs slash heads
slash master.
</h2>
<h2>
So in other words this is I'll simplify it head is pointing to the master branch if I switch branches
get switch oldies whoops can't do that from here.
I have to back out now if I switch because I was in the docket directory, gets very confused, get
switched to oldies and now I take a look again.
So I'll do cats dot git slash head.
I'm now outside that folder.
See this?
It now references oldies.
So if I switch back to Master.
And I take a look at head.
It's now master.
So that thing, that file called Head is just referencing a particular branch.
Now this thing here, refs slash heads slash master or refs slash heads slash oldies right here.
They actually reference a particular commit.
</h2>
<h2>
So let's take a look.
I'm going to open up the docket directory now.
I've opened up the git directory just in finder here and let's take a look at this.
Refs slash heads slash master.
So refs heads and you'll see there's a file for every branch that I have.
And in each one of these files, there's just one thing.
I'm going to open it in my text editor.
It's just a commit hash it's just a pointer to a particular commit and head in turn is pointing to one
of those branch references.
So remember head was reps, slash heads, slash master.
That's what it had inside.
And then if we look at what that actually is.
It's a comet 93 E RD.
That is where the master branch left off.
That's where the bookmark for master branches.
Now, if I switch to the oldest branch, nothing changes in this master reference.
Right.
But we know that my head changed so we could take a look at that again.
Cat dot get slash head.
There it is.
Head slash oldies and if we look at that.
All this.
It says the last commit on the oldest branch is seven FD and if we type git log, that's exactly what
we see.
Seven FD.
Right, so we can see that all over the place.
I have this 2000 branch and it says the last commit on there zero to F four OC.
And so if we switch to that branch get switch two thousandths.
Typekit log.
There it is.
There are 2f4.
So each one of these is like a bookmark.
It's one of these branch references.
</h2>
<h2>
So we happen to have what, five of them instead of two?
In this diagram, each one refers to a commit.
It just stores that commit hash in a file and then head changes.
This file right here changes depending on what we have checked out, which branch we're currently on.
So again, this really doesn't matter if you understand it or not.
In terms of using Git, it's not a big deal as long as you understand the fact that head is just whatever
you're currently checked out on, whatever you're what branch you're on.
But behind the scenes, this is the mechanism.
It's just a file and it references a particular branch reference.
We look at those branch references, they in turn refer to a particular commit.
</h2>
<h2>
So pretty simple when you look at it this way.
So hopefully this diagram plus this starts to sort of congeal branch reference points to a commit,
this one points to a different commit head, just points to one of those branch references so we can
stay on dark mode or I could toggle back to master, but these stay the same.
The branch reference, they both stay the same head is all that's changing until I do more work and
make new commits anyway.
So the optional I'm sure I'm boring you to death, so I'm going to stop.
</h2>
<h1>===================</h1>
<h1>MERGING BRANCHES</h1>
<h1>===================</h1>
<h2>
    In this section we'll see how we merge branches, and there are 
    different types of merges, here's an overview of each section 
    based on importance.
</h2>
<h1> Critical importance:
    <ul>
        <li>Fast Forward Merges</li>
        <li>Git Merge and Merge commit commands</li>
        <li>Resolving merge conflicts</li>
    </ul>
</h1>
<h1> Nice to know but not critical:
    <ul>
        <li>
Using VsCode to resolve conflicts
        </li>
    </ul>
</h1>
<h2>
    Now let's get into it, how do we merge branches, an essential 
    thing we must learn, to do this we use the git merge command
</h2>
<h2>
    This is a common part of git workflow especially when working 
    on a team, you're going to be using git merge frequently 
    in a developer role. 
</h2>
<h2>
    So a big thing to know is that we don't ever experiment 
    merging with master until a feature is 100% approved to 
    merge back to master branch, you'll leave master alone 
    until your "feature branch" or branch you're editing 
    has been completely fleshed out and approved for a merge.
</h2> 
<h2>
    So everyone at X company works on their own unique 
    feature branch, your co-workers will have their own 
    branches that they're editing for a specified task same 
    as yourself, then maybe you'll merge branches at some 
    point.
</h2>

<h2>
    Remember we merge branches themselves, not commits, and we always merge 
    to the current HEAD branch
</h2>
<h2>
    When we want to merge, we follow these steps:
    <ol>
        <li>
            Switch into the branch you'd like to merge the changes 
            into(the receiving branch) using git switch command: git switch 
            master
        </li>
   <li>
    Use the git merge command to merge the changes from a specific branch 
    into the current branch, which from above would be master: git merge bugfix

   </li>
    </ol>
So it's essentially: git switch into the branch you want to merge changes 
into, then once inside the selected branch, use git merge bugfix or git merge + 
branch name we want to merge into master
</h2>

































</body>
<script src="script.js"></script>
</html>